[
    {
        "level": "##",
        "title": "Hyper Strategy Logic",
        "content": "\nRaven Beutner CISPA Helmholtz Center for Information Security Germany\n"
    },
    {
        "level": "##",
        "title": "Abstract",
        "content": "\nStrategy logic (SL) is a powerful temporal logic that enables strategic reasoning in multi-agent systems. SL supports explicit (first-order) quantification over strategies and provides a logical framework to express many important properties such as Nash equilibria, dominant strategies, etc. While in SL the same strategy can be used in multiple strategy profiles, each such profile is evaluated w.r.t. a pathproperty, i.e., a property that considers the *single* path resulting from a particular strategic interaction. In this paper, we present Hyper Strategy Logic (HyperSL), a strategy logic where the outcome of multiple strategy profiles can be compared w.r.t. a *hyperproperty*, i.e., a property that relates *multiple* paths. We show that HyperSL\ncan capture important properties that cannot be expressed in SL, including non-interference, quantitative Nash equilibria, optimal adversarial planning, and reasoning under imperfect information. On the algorithmic side, we identify an expressive fragment of HyperSL with decidable model checking and present a model-checking algorithm. We contribute a prototype implementation of our algorithm and report on encouraging experimental results.\n"
    },
    {
        "level": "##",
        "title": "Keywords",
        "content": "\nStrategy Logic, Hyperproperties, Model Checking, Imperfect Information, Nash Equilibrium, Information-Flow Cotrol ACM Reference Format:\nRaven Beutner and Bernd Finkbeiner. 2024. Hyper Strategy Logic. In Proc.\n\nof the 23rd International Conference on Autonomous Agents and Multiagent Systems (AAMAS 2024), Auckland, New Zealand, May 6 - 10, 2024, IFAAMAS,\n18 pages.\n"
    },
    {
        "level": "##",
        "title": "1 Introduction",
        "content": "\nTwo important developments in the area of reactive systems concern the study of strategic properties in multi-agent systems (MAS)\nand the study of hyperproperties. *Strategic properties* analyze the ability of agents to achieve a goal against (or in cooperation) with other agents. Logics such as alternating-time temporal logic (ATL\u2217)\n[2] and strategy logic (SL) [24, 45] reason about the temporal interaction of such agents and allow for rigorous correctness guarantees using techniques such as model-checking. *Hyperproperties* [27] are properties that relate *multiple* executions within a system. Hyperproperties occur in many situations in computer science where traditional path properties (that refer to *individual* system execution) are not sufficient. Typical examples include **(1)** *optimality*, e.g., This work is licensed under a Creative Commons Attribution International 4.0 License.\n\nBernd Finkbeiner CISPA Helmholtz Center for Information Security Germany\n\none path reaching a goal faster than all other paths; **(2)**_information-flow policies_, e.g., requiring that any two paths with identical low-security input should produce the same low-security output [42]; and **(3) robustness_, i.e., stating that similar inputs should lead to similar outputs [25].\n\nSuch hyperproperties are also of vital importance in MASs. For example, we might ask if some agent has a strategy to achieve a goal without leaking information (an information-flow property) or can achieve a goal faster than some other agent (an optimality requirement). Yet existing logics for strategic reasoning (such as variants of SL [24, 45]) cannot express such hyper-requirements (we discuss related approaches in Section 2). We illustrate this on the example of Nash equilibria.\n\nAssume we are given a MAS with agents $\\{1,\\ldots,n\\}$ and LTL properties $\\psi_{1},\\ldots,\\psi_{n}$ that describe the objectives of the agents. Agent $i$ wants to make sure that $\\mathsf{F}\\,\\psi_{i}$ holds, i.e., formula $\\psi_{i}$_eventually_ holds. We want to check whether the system admits a Nash equilibrium, i.e., there exists a strategy for each agent such that no agent has an incentive to deviate in order to fulfill her objective [48]. In SL, we can express the existence of a Nash equilibrium as follows:\n\n$$\\exists x_{1},\\ldots,x_{n}.\\,\\psi_{n}.\\,\\bigwedge_{i=1}^{n}\\Bigl{(}(\\mathsf{F}\\,\\psi_{i})(\\vec{x}[i\\mapsto y])\\to(\\mathsf{F}\\,\\psi_{i})(\\vec{x})\\Bigr{)}$$ where we abbreviate the strategy profiles $\\vec{x}=(x_{1},\\ldots,x_{n})$ and $\\vec{x}[i\\mapsto y]=(x_{1},\\ldots,x_{i-1},y,x_{i+1},\\ldots,x_{n})$. In the variant SL we consider here (similar to the SL by Chatterjee et al. [24]), atomic formulas have the form $\\psi(\\vec{x})$ where $\\psi$ is an LTL formula, and $\\vec{x}$ is a strategy profile that assigns a strategy to each agent. Formula $\\psi(\\vec{x})$ holds if the unique path that results from the interaction of the strategies in $\\vec{x}$ satisfies $\\psi$. The above formula thus states that if some agent $i$ can achieve $\\psi$? by playing some deviating strategy $y$ instead of $x_{i}$, i.e., the unique play that results from strategy profile also holds under strategy profile $\\vec{x}$.\n\nIn the formula, we effectively compare two plays under strategy profiles $\\vec{x}$ and $\\vec{x}[i\\mapsto y]$. However, SL limits the comparison between multiple interactions to a boolean combination of LTL properties on their outcomes (paths). In game-theoretic terms, the above formula assumes that the reward for each agent is binary; the reward of agent $i$ is maximal if $\\mathrm{F}\\,\\psi_{i}$ holds and minimal if it does not. This fails to capture quantitative reward, for example, in a setting where agent $i$ receives a higher reward (and thus deviates) by fulfilling $\\psi_{i}$_someor_. To express the existence of such a quantitative equilibrium, a boolean formula over individual temporal properties on strategy profiles $\\vec{x}$ and $\\vec{x}[i\\mapsto y]$ is not sufficient. We need a more powerful mechanism that can compare the temporal behavior of _multiple_ paths: a _hyperproperty_.\n\nHyperSL. In this paper, we propose HyperSL - a new temporal logic that combines first-order strategic reasoning (as in SL) with\n\nthe ability to compare _multiple_ paths w.r.t. a hyperproperty. Syntatically, we use path variables to refer to multiple paths at the same time (similar to existing hypergencies such as HyperCTL[26] and HyperALPLE[14, 117]). In HyperS${}_{1}$, atomic formulas have the form $\\psi[\\pi_{1}:\\vec{x}_{1}\\ldots,\\vec{x}_{m}:\\vec{x}_{m}]$ where $\\pi_{1},\\ldots,\\pi_{m}$ are path variables, $\\vec{x}_{1},\\ldots,\\vec{x}_{m}$ are strategy profiles (assigning a strategy to each agent), and $\\psi$ is an LTL formula where atomic propositions are indexed by path variables from $\\pi_{1},\\ldots,\\pi_{m}$. The formula states that the plays resulting from strategy profiles $\\vec{x}_{1},\\ldots,\\vec{x}_{m}$, when bound to $\\pi_{1},\\ldots,\\pi_{m}$, (together) satisfy the hyperproperty expressed by $\\psi$.\n\nComing back to the Nash equilibrium example from before, we can use HyperS${}_{1}$ to express the existence of a Nash equilibrium in a quantitative reward setting as follows:\n\n$$\\exists x_{1},\\ldots,x_{n}.\\forall y.\\bigwedge_{i=1}^{n}\\left((\\neg\\psi_{i\\pi_{1}}\\ \\mathsf{W}\\,\\psi_{i\\pi_{2}})\\left[\\pi_{1}:\\vec{x}[i\\mapsto y]\\right]\\right)$$\n\nHere, we write $\\psi_{i\\pi_{1}}\\left(\\neg\\psi_{i\\pi_{1}}\\ \\mathsf{W}\\,\\psi_{i\\pi_{2}}\\right)$ to state that $\\psi_{i}$ holds on path $\\pi_{1}$ (resp. $\\pi_{2}$). In the formula, we again quantify over a deviating strategy $y$, but can compare the two paths resulting from strategy $\\vec{x}[i\\mapsto y]$ and $\\vec{x}$ within the _same_ temporal formula. This formula states that path $\\pi_{1}$ (constructed using strategy profile $\\vec{x}[i\\mapsto y]$ does not satisfy $\\psi_{i}$ strictly before $\\psi_{i}$ holds on path $\\pi_{2}$ (constructed using strategy profile $\\vec{x})$.[1] If the above formula holds, $\\vec{x}$ is thus constitutes a strategy profile such that no agent could achieve its goal strictly sooner (if at all).\n\nNote that we can express any Nash equilibrium as long as \"agent\"\n\ud835\udc56 (strictly) prefers the outcome on path \ud835\udf0b1 over that on path \ud835\udf0b2\" is expressible using an LTL formula over \ud835\udf0b1, \ud835\udf0b2. Likewise, HyperSL\ncan, e.g., express that some strategy **(1)** reaches a goal without leaking information, **(2)** is at least as fast as any other strategy, or\n(3) is robust w.r.t. the behavior of other agents.\n\nExpressiveness of HyperSL. After we introduce HyperSL (in Section 4), we study its relation to existing logics (in Section 5). We show that HyperSL subsumes many non-hyper strategy logics as well as hyperlogics such as HyperCTL\u2217 [26], HyperATL\u2217 [14, 17], and HyperATL\u2217\n\ud835\udc46 [18] (see Section 2). Moreover, HyperSL also admits reasoning under imperfect information despite having a semantics defined under complete information. The key observation here is that \"acting under imperfect information\" *is a hyperproperty*: a strategy acts under imperfect information if, on any *pair* of paths with the same observation, the strategy chooses the same action.\n\nFormally, we show that HyperSL subsumes SLii [12, 13], a strategy logic centered around imperfect information.\n\nModel Checking. HyperSL's ability to compare multiple strategic interactions renders model-checking (MC) undecidable. In Section 6, we identify a fragment of our logic - called HyperSL[SPE] - for which MC is possible. Intuitively, in HyperSL[SPE], the quantifier prefix should be such that we can group it into individual \"blocks\"\nwhere the strategy variables from each block are used on independent path variables. HyperSL[SPE] subsumes SL[1G] (the singlegoal fragment of SL) [46], HyperLTL [26], HyperATL\u2217 [14, 17], and HyperATL\u2217\n\ud835\udc46 [18], but also captures properties that cannot be expressed in existing logics. We argue that HyperSL[SPE] is the largest fragment with a decidable model-checking problem that is defined purely in terms of the quantification structure.\n\nImplementation and Experiments. We implement our MC algorithm for HyperSL[SPE] in the HyMASMC tool [18] and experiment with various MAS models (in Section 7). Our experiments show that HyMASMC performs well on many *non*-hyper strategy logic specifications and can verify complex hyperproperties that cannot be expressed in any existing logic.\n"
    },
    {
        "level": "##",
        "title": "2 Related Work",
        "content": "\nSL has been extended along multiple dimensions, including agentunbinding [37], reasoning about probabilities [4], epistemic properties [7, 10, 41], and quantitative properties [20]. We refer to [45, 49] for a more in-depth discussion. The common thread in all the previous extensions is a focus on the temporal behavior on individual paths. HyperSL generalizes SL and is the first to compare multiple paths. Even quantitative extensions like SL[F ] [20] evaluate an LTL[F ]-formula on a *per-path* basis. In contrast, HyperSL can express complex relationships *between* paths.\n\nStudying logics that can express strategic properties under imperfect information has attracted much attention and led to various extensions of ATL\u2217 [10, 11, 22, 29, 38] and SL [12, 36]. Berthon et al. [12] showed that their logic, SLii, subsumes most existing approaches. We show that HyperSL can also reason about imperfect information (and subsumes SLii) despite having a semantics that is defined under full information.\n\nLogics for expressing hyperproperties in non-agent-based systems (e.g., labeled transition systems) have been obtained by extending existing temporal or first-order logics with explicit path quantification over path/trace variables or an equal-level predicate [15, 26, 28, 34, 35]. As strategic reasoning is significantly more powerful than pure path quantification, HyperSL subsumes HyperCTL\u2217 (when interpreting transition systems as single-agent MASs). HyperATL\u2217 [14, 17] and HyperATL\u2217\n\ud835\udc46 [18] extend alternatingtime temporal logic (ATL\u2217) [2] with path variables and strategysharing constraints, leading to a strategic hyperlogic that can express important security properties such as non-deducibility of strategies [54] and simulation security [51]. Similar to ATL\u2217, the strategic reasoning in HyperATL\u2217 and HyperATL\u2217\n\ud835\udc46 is limited to implicit reasoning about the strategic ability of coalitions of agents and cannot explicitly reason about strategies as, e.g., needed to express the existence of a Nash equilibrium.\n\nOur model-checking algorithm for HyperSL[SPE] is based on an iterative elimination of path (variables) in an automaton, similar to existing algorithms for HyperCTL\u2217 [33] and HyperATL\u2217 [17, 18].\n\nCompared to HyperATL\u2217, we need to eliminate paths by simulating an *arbitrary* prefix of strategy quantifiers, leading to a more involved construction and more complex correctness proof.\n"
    },
    {
        "level": "##",
        "title": "3 Preliminaries",
        "content": "\nWe let AP be a fixed finite set of atomic propositions and fix a fixed finite set of agents Agts = {1*, . . . ,*\ud835\udc5b}. Given a set \ud835\udc4b, we write \ud835\udc4b +\n(resp. \ud835\udc4b\ud835\udf14) for the set of non-empty finite (resp. infinite) sequences over \ud835\udc4b. For \ud835\udc62 \u2208 \ud835\udc4b\ud835\udf14 and \ud835\udc57 \u2208 N, we write \ud835\udc65(\ud835\udc57) for the \ud835\udc56th element,\n\ud835\udc62[0, \ud835\udc57] for the finite prefix up to position \ud835\udc57 (of length \ud835\udc57 + 1), and \ud835\udc62[\ud835\udc57, \u221e] for the infinite suffix starting at position \ud835\udc57.\n\n\ud835\udc56\u2208*Agts* \ud835\udc4e\ud835\udc56 for the action profile where each agent Concurrent Game Structures. As the underlying model of MASs, we use concurrent game structures (CGS) [2]. A CGS is a tuple G = (\ud835\udc46,\ud835\udc600, A*,\ud835\udf05, \ud835\udc3f*) where \ud835\udc46 is a finite set of states, \ud835\udc600 \u2208 \ud835\udc46 is an initial state, A is a finite set of actions, \ud835\udf05 : \ud835\udc46 \u00d7 (*Agts* \u2192 A) \u2192 \ud835\udc46 is a transition function, and \ud835\udc3f : \ud835\udc46 \u2192 2AP is a labeling function. The transition function takes a state \ud835\udc60 and an action profile \ufffd\ud835\udc4e : *Agts* \u2192 A\n(mapping each agent an action) and returns a unique successor state\n\ud835\udf05(\ud835\udc60, \ufffd\ud835\udc4e). We write \ufffd\n\ud835\udc56 is assigned action \ud835\udc4e\ud835\udc56.\n\nA strategy in G is a function \ud835\udc53 : \ud835\udc46+ \u2192 A, mapping finite plays to actions. We denote the set of all strategies in G with Str(G). A *strategy profile* \ufffd\n\ud835\udc56\u2208*Agts* \ud835\udc53\ud835\udc56 assigns each agent \ud835\udc56 a strategy \ud835\udc53\ud835\udc56 \u2208 *Str*(G). Given strategy profile \ufffd\n\ud835\udc56\u2208*Agts* \ud835\udc53\ud835\udc56 and state \ud835\udc60 \u2208 \ud835\udc46, we can define the unique path resulting from the interaction between the agents: We define *Play*G(\ud835\udc60, \ufffd\n\ud835\udc56\u2208Agts \ud835\udc53\ud835\udc56 (\ud835\udc5d[0, \ud835\udc57]) in which each agent\n\ud835\udc56\u2208*Agts* \ud835\udc53\ud835\udc56) as the unique path \ud835\udc5d \u2208 \ud835\udc46\ud835\udf14 such that \ud835\udc5d(0) = \ud835\udc60 and for every \ud835\udc57 \u2208 N we have\n\ud835\udc5d(\ud835\udc57 + 1) = \ud835\udf05\ufffd\ud835\udc5d(\ud835\udc57), \ufffd\n\ud835\udc56 plays the action determined by \ud835\udc53\ud835\udc56 on the current prefix \ud835\udc5d[0, \ud835\udc57].\n\n\ud835\udc56\u2208Agts \ud835\udc53\ud835\udc56 (\ud835\udc5d[0, \ud835\udc57])\ufffd. That is, in every step, we construct the action profile \ufffd\nAlternating Automata. Our model-checking algorithm is based on alternating automata over infinite words. These automata generalize nondeterministic automata by alternating between nondeterministic and universal transitions [53]. For transitions of the former kind, we can choose *some* successor state; for transitions of the latter type, we need to consider *all* possible successor states. Formally, an *alternating parity automaton (APA)* over alphabet \u03a3 is a tuple A = (\ud835\udc44,\ud835\udc5e0*,\ud835\udeff,\ud835\udc50*) where \ud835\udc44 is a finite set of states, \ud835\udc5e0 \u2208 \ud835\udc44 is an initial state, \ud835\udc50 : \ud835\udc44 \u2192 N is a color assignment, and \ud835\udeff : \ud835\udc44 \u00d7 \u03a3 \u2192 B+(\ud835\udc44)\nis a transition function that maps each state-letter pair to a positive boolean formula over \ud835\udc44 (denoted with B+(\ud835\udc44)). For example, if \ud835\udeff(\ud835\udc5e,\ud835\udc59) = \ud835\udc5e1 \u2228 (\ud835\udc5e2 \u2227 \ud835\udc5e3), we can - from state \ud835\udc5e \u2208 \ud835\udc44 and upon reading letter \ud835\udc59 \u2208 \u03a3 - either move to state \ud835\udc5e1 or move to *both* \ud835\udc5e2\nand \ud835\udc5e3 (i.e., we spawn two copies of our automaton, one starting in state \ud835\udc5e2 and one in \ud835\udc5e3). We write L(A) \u2286 \u03a3\ud835\udf14 for the set of all infinite words for which we can construct a run tree that respects the transition formulas such that the *minimal* color that occurs infinitely many times (as given by \ud835\udc50) is *even*. For space reasons, we cannot give a formal semantics of APA runs and instead refer the reader to Appendix A. No specific knowledge about APAs is required to understand the high-level idea of our algorithm.\n\nA special kind of APAs are deterministic parity automata (DPA)\nin which \ud835\udeff is a function \ud835\udc44 \u00d7 \u03a3 \u2192 \ud835\udc44 assigning a unique successor state to each state-letter pair. We can always determinize APAs:\nProposition 1 ([44, 50]). For any APA A with \ud835\udc5b states, we can effectively compute a DPA A\u2032 with at most 22O(\ud835\udc5b) states such that L(A) = L(A\u2032).\n"
    },
    {
        "level": "##",
        "title": "4 Hyper Strategy Logic",
        "content": "\nOur new logic HyperSL is centered around the idea of combining strategic reasoning (as possible in strategy logic [24, 45]) with the ability to express hyperproperties (as possible in logics such as HyperCTL\u2217 [26]). To accomplish this, we combine the ideas from both disciples. On the strategy-logic-side, we use strategy variables to quantify over strategies. On the hyper-side, we use path variables to compare multiple paths within a temporal formula.\n\nLet X be a set of *strategy variables* and V a set of *path variables*.\n\nWe typically use lowercase letters (\ud835\udc65,\ud835\udc66,\ud835\udc67,\ud835\udc651*, . . .*) for strategy variables and variations of \ud835\udf0b (\ud835\udf0b, \ud835\udf0b\u2032, \ud835\udf0b1*, . . .*) for path variables. Path and state formulas in HyperSL are generated by the following grammar:\n\ud835\udf13 := \ud835\udc4e\ud835\udf0b | \ud835\udf11\ud835\udf0b | \ud835\udf13 \u2227\ud835\udf13 | \u00ac\ud835\udf13 | X\ud835\udf13 | \ud835\udf13 U\ud835\udf13\n\ud835\udf11 := \u2200\ud835\udc65.\ud835\udf11 | \u2203\ud835\udc65.\ud835\udf11 | \ud835\udf13\n\ufffd\n\ud835\udf0b1 : \ufffd\ud835\udc651, . . . , \ud835\udf0b\ud835\udc5a : \ufffd\ud835\udc65\ud835\udc5a\n\ufffd\nwhere \ud835\udc4e \u2208 AP is an atomic proposition, \ud835\udf0b, \ud835\udf0b1*, . . . , \ud835\udf0b*\ud835\udc5a \u2208 V are path variables, \ud835\udc65 \u2208 X is a strategy variable, and \ufffd\ud835\udc651, . . . , \ufffd\ud835\udc65\ud835\udc5a : *Agts* \u2192 X\nare *strategy profiles* that assign a strategy variable to each agent.\n\nWe often write\ud835\udf13 [\ud835\udf0b\ud835\udc58 : \ufffd\ud835\udc65\ud835\udc58]\ud835\udc5a\n\ud835\udc58=1 as a shorthand for\ud835\udf13 [\ud835\udf0b1 : \ufffd\ud835\udc651*, . . . , \ud835\udf0b*\ud835\udc5a :\n\ufffd\ud835\udc65\ud835\udc5a]. We use Q as a placeholder for either \u2200 or \u2203. We use the standard Boolean connectives \u2228, \u2192, \u2194, and constants \u22a4, \u22a5, as well as the derived LTL operators *eventually* F\ud835\udf13 := \u22a4 U\ud835\udf13 and globally G\ud835\udf13 := \u00ac F \u00ac\ud835\udf13. For each formula \ud835\udf13 [\ud835\udf0b\ud835\udc58 : \ufffd\ud835\udc65\ud835\udc58]\ud835\udc5a\n\ud835\udc58=1, we assume that all path variables that are free in \ud835\udf13 belong to {\ud835\udf0b1*, . . . , \ud835\udf0b*\ud835\udc5a}, i.e., all used path variables are bound to some strategy profile. We further assume that all nested state formulas are closed.\n\nNote that our syntax does not support boolean combinations of state formulas as is usual in SL [45]. As we can evaluate a path formula on multiple paths, we can move boolean combinations within the path formulas.\n\n  Example 1. Consider the SL formula \u2203\ud835\udc65. (\u2203\ud835\udc66.(F\ud835\udc4e)(\ud835\udc65,\ud835\udc66)) \u2227 (\u2200\ud835\udc67.\n(G\ud835\udc4f)(\ud835\udc67,\ud835\udc65)), which can be expressed in HyperSL as follows: \u2203\ud835\udc65. \u2203\ud835\udc66. \u2200\ud835\udc66.\n(F\ud835\udc4e\ud835\udf0b1 \u2227 G\ud835\udc4f\ud835\udf0b2)[\ud835\udf0b1 : (\ud835\udc65,\ud835\udc66), \ud835\udf0b2 : (\ud835\udc67,\ud835\udc65)].\n                                                        \u25b3\n\nSemantics. We fix a game structure G = (\ud835\udc46,\ud835\udc600, A,\ud835\udf05, \ud835\udc3f). A strategy\nassignment is a partial mapping \u0394 : X \u21c0 Str(G). We write {} for\nthe unique strategy assignment with an empty domain. In HyperSL,\na path formula \ud835\udf13 refers to propositions on multiple path variables.\nWe evaluate it in the context of a path assignment \u03a0 : V \u21c0 \ud835\udc46\ud835\udf14 map-\nping path variables to paths (similar to the semantics of HyperCTL\u2217\n\n[26]). Given \ud835\udc57 \u2208 N, we define \u03a0[\ud835\udc57, \u221e] as the shifted assignment\ndefined by \u03a0[\ud835\udc57, \u221e](\ud835\udf0b) := \u03a0(\ud835\udf0b)[\ud835\udc57, \u221e]. For a path formula \ud835\udf13, we\nthen define the semantics in the context of path assignment \u03a0:\n\n\u03a0 |=G \ud835\udc4e\ud835\udf0b\n           iff\n              \ud835\udc4e \u2208 \ud835\udc3f\ufffd\u03a0(\ud835\udf0b)(0)\ufffd\n\n\u03a0 |=G \ud835\udf11\ud835\udf0b\n           iff\n              \u03a0(\ud835\udf0b)(0), {} |=G \ud835\udf11\n\n\u03a0 |=G \ud835\udf131 \u2227\ud835\udf132\n           iff\n              \u03a0 |=G \ud835\udf131 and \u03a0 |=G \ud835\udf132\n\u03a0 |=G \u00ac\ud835\udf13\n           iff\n              \u03a0 \u0338|=G \ud835\udf13\n\n\u03a0 |=G X\ud835\udf13\n           iff\n              \u03a0[1, \u221e] |=G \ud835\udf13\n\n$$\\Pi\\models_{\\mathcal{G}}\\psi_{1}\\cup\\psi_{2}\\qquad\\text{iff}\\quad\\exists j\\in\\mathbb{N}.\\Pi[j,\\infty]\\models_{\\mathcal{G}}\\psi_{2}\\text{and}$$ $$\\forall0\\leq k<j.\\Pi[k,\\infty]\\models_{\\mathcal{G}}\\psi_{1}$$\n\nThe semantics for path formulas synchronously steps through all paths in $\\Pi$ and evaluate $a_{\\pi}$ on the path bound to $\\pi$. State formulas are evaluated in a state $s\\in S$ and strategy assignment $\\Delta$ as follows:\n\n$$s,\\Lambda\\models_{\\mathcal{G}}\\forall x.\\varphi\\qquad\\qquad\\text{iff}\\quad\\forall f\\in Str(\\mathcal{G}).\\,s,\\Delta[x\\mapsto f]\\models_{\\mathcal{G}}\\varphi$$ $$s,\\Lambda\\models_{\\mathcal{G}}\\exists x.\\varphi\\qquad\\qquad\\text{iff}\\quad\\exists f\\in Str(\\mathcal{G}).\\,s,\\Delta[x\\mapsto f]\\models_{\\mathcal{G}}\\varphi$$ $$s,\\Lambda\\models_{\\mathcal{G}}\\psi\\left[\\pi_{k}:\\vec{x}_{k}\\right]_{k=1}^{m}\\quad\\text{iff}$$ $$\\left[\\pi_{k}\\mapsto Play_{\\mathcal{G}}\\left(s,\\prod_{i\\in Agts}\\Lambda(\\vec{x}_{k}(i))\\right)\\right]_{k=1}^{m}\\models_{\\mathcal{G}}\\psi$$\n\nTo resolve a formula $\\psi\\left[\\pi_{k}:\\vec{x}_{k}\\right]_{k=1}^{m}$, we construct $m$ paths (bound to $\\pi_{1},\\ldots,\\pi_{m}$), and evaluate $\\psi$ in the resulting path assignment. The \n\ud835\udc58th path (bound to \ud835\udf0b\ud835\udc58) is the play where each agent \ud835\udc56 plays strategy\n\u0394(\ufffd\ud835\udc65\ud835\udc58 (\ud835\udc56)), i.e., the strategy currently bound to the strategy variable\n\ufffd\ud835\udc65\ud835\udc58 (\ud835\udc56). We write G |= \ud835\udf11 if \ud835\udc600, {} |=G \ud835\udf11, i.e., the initial state satisfies state formula \ud835\udf11.\n"
    },
    {
        "level": "##",
        "title": "5 Expressiveness Of Hypersl",
        "content": "\nThe ability to compare multiple paths within a temporal formula makes HyperSL a powerful formalism that subsumes many existing logics. We only briefly mention some connections to existing logics. More details can be found in Appendix B.\n"
    },
    {
        "level": "##",
        "title": "5.1 Sl And Hypersl",
        "content": "\nHyperSL naturally subsumes many (non-hyper) strategy logics\n[24, 45], which evaluate temporal properties on *individual* paths.\n\nWe consider SL formulas defined by the following grammar:\n\n$$\\psi:=a\\mid\\varphi\\mid\\neg\\psi\\mid\\psi\\wedge\\psi\\mid\\mathsf{X}\\psi\\mid\\psi\\cup\\psi$$ $$\\varphi:=\\psi\\mid\\varphi\\wedge\\varphi\\mid\\varphi\\vee\\varphi\\mid\\forall x.\\,\\varphi\\mid\\exists x.\\,\\varphi\\mid(i,x)\\varphi$$\n\nwhere $a\\in AP$, $x\\in\\mathcal{X}$, and $i\\in\\mathit{Agts}$. We assume that nested state formulas are closed. In this SL, we can quantify over strategies and $bind$ a strategy $x$ to agent $i$ using $(i,x)$; see Appendix B.1 for the full semantics. We can show the following:\nLemma 1. For any SL formula \ud835\udf11 there exists a HyperSL formula\n\ud835\udf11\u2032 *such that for any CGS* G, G |=SL \ud835\udf11 *iff* G |= \ud835\udf11\u2032.\n\nProof Sketch. We use a unique path variable \ufffd\ud835\udf0b. During translation, we track the current strategy (variable) for each agent and construct \ufffd\ud835\udf0b using the resulting strategy profile.\n\n\u25a1\n\n  Example 2. Consider the formula \u2203\ud835\udc65. \u2200\ud835\udc66. (1,\ud835\udc65)(2,\ud835\udc66)(3,\ud835\udc66) G F\ud835\udc4e.\nWe can express this formula in HyperSL as \u2203\ud835\udc65. \u2203\ud835\udc66. \ufffd G F\ud835\udc4e \ufffd\ud835\udf0b\n                                                    \ufffd[ \ufffd\ud835\udf0b :\n(\ud835\udc65,\ud835\udc66,\ud835\udc66)] where (\ud835\udc65,\ud835\udc66,\ud835\udc66) denotes the strategy profile mapping agent 1\nto \ud835\udc65, and agents 2 and 3 to \ud835\udc66.\n                                                       \u25b3\n"
    },
    {
        "level": "##",
        "title": "5.2 Hyperatl\u2217 And Hypersl",
        "content": "\nCompared to SL, ATL\u2217 [2] offers a weaker (implicit) form of strategic reasoning. The ATL\u2217 formula \u23b7\ud835\udc34\u2304\ud835\udf13 expresses that the agents in\ud835\udc34 \u2286\nAgts have a joint strategy to ensure path formula\ud835\udf13 [2]. HyperATL\u2217\n[14, 17] is an extension of ATL\u2217 that can express hyperproperties, generated by the following grammar:\n\n$$\\psi:=a_{\\pi}\\mid\\neg\\psi\\mid\\psi\\wedge\\psi\\mid\\mathsf{X}\\,\\psi\\mid\\psi\\U\\psi$$ $$\\varphi:=\\langle\\!\\langle A\\rangle\\!\\rangle\\pi.\\,\\varphi\\mid[\\![A]\\!]\\pi.\\,\\varphi\\mid\\psi$$\n\nwhere $a\\in AP$, $\\pi\\in\\mathcal{V}$, and $A\\subseteq\\mathit{Agts}$. Formula $\\langle\\!\\langle A\\rangle\\!\\rangle\\pi.\\,\\varphi$ states that the agents in $A$ have a strategy such that any path under that strategy, when bound to path variable $\\pi$, satisfies the remaining formula $\\varphi$. Likewise, $[\\![A]\\!]\\pi.\\,\\varphi$ states that, no matter what strategy the agents in $A$ play, some compatible path, when bound to $\\pi$, satisfies $\\varphi$. See Appendix B.2 for the full HyperAIL${}^{*}$ semantics. We can show the following:\nLemma 2. For any HyperATL\u2217 formula \ud835\udf11 there exists a HyperSL\nformula \ud835\udf11\u2032 *such that for any CGS* G, G |=HyperATL\u2217 \ud835\udf11 *iff* G |= \ud835\udf11\u2032.\n\nProof Sketch. Similar to the translation of ATL\u2217 to SL [24, 45], we translate each HyperATL\u2217 quantifier \u23b7\ud835\udc34\u2304\ud835\udf0b (resp. \ufffd\ud835\udc34\ufffd\ud835\udf0b) using existential (resp. universal) quantification over fresh strategies for all agents in \ud835\udc34, followed by universal (resp. existential) quantification over strategies for agents in *Agts* \\ \ud835\udc34 and use these strategies to construct path \ud835\udf0b.\n\n\u25a1\nExample 3. Consider the HyperATL\u2217 *formula* \u23b7{1, 2}\u2304\ud835\udf0b1. \u23b7{3}\u2304\n\ud835\udf0b2. (\ud835\udc4e\ud835\udf0b1 U\ud835\udc4f\ud835\udf0b2). We can express this in HyperSL as \u2203\ud835\udc651,\ud835\udc652. \u2200\ud835\udc653. \u2203\ud835\udc663.\n\n\u2200\ud835\udc661,\ud835\udc662. (\ud835\udc4e\ud835\udf0b1 U\ud835\udc4f\ud835\udf0b2)\n\ufffd\n\ud835\udf0b1 : (\ud835\udc651,\ud835\udc652,\ud835\udc653), \ud835\udf0b2 : (\ud835\udc661,\ud835\udc662,\ud835\udc663)\n\ufffd\n.\n\n\u25b3\nBy Lemma 2, HyperSL thus captures the various security hyperproperties (such as non-deducibility of strategies [54] and simulation security [51]) that can be expressed in HyperATL\u2217 [14]. We can extend Lemma 2 further to also capture the strategy sharing constraints found in HyperATL\u2217\n\ud835\udc46 [18].\n\n  Lemma 3. For any HyperATL\u2217\n                          \ud835\udc46 formula \ud835\udf11 there exists a HyperSL\nformula \ud835\udf11\u2032 such that for any CGS G, G |=HyperATL\u2217\n                                         \ud835\udc46 \ud835\udf11 iff G |= \ud835\udf11\u2032.\n\n  Moreover, HyperSL can express properties that go well beyond\nthe strict \u2203\u2200 and \u2200\u2203 quantifier alternation found in HyperATL\u2217 and\nHyperATL\u2217\n         \ud835\udc46 (as, e.g., needed for Nash equilibria).\n"
    },
    {
        "level": "##",
        "title": "5.3 Imperfect Information And Hypersl",
        "content": "\nIn recent years, much effort has been made to study strategic behavior under *imperfect information* [9\u201312, 29, 36]. In such a setting, an agent acts strategically (i.e., decides on an action based on its past experience) but only observes parts of the overall system. Perhaps surprisingly, HyperSL is expressive enough to allow reasoning under imperfect information despite having a semantics with complete information (cf. Section 4). Concretely, we consider strategy logic under imperfect information (SLii), an extension of SL with imperfect information [12, 13] defined as follows:\n\ud835\udf13 := \ud835\udc4e | \ud835\udf11 | \u00ac\ud835\udf13 | \ud835\udf13 \u2227\ud835\udf13 | X\ud835\udf13 | \ud835\udf13 U\ud835\udf13\n\ud835\udf11 := \ud835\udf13 | \ud835\udf11 \u2227 \ud835\udf11 | \ud835\udf11 \u2228 \ud835\udf11 | \u2200\ud835\udc65\ud835\udc5c.\ud835\udf11 | \u2203\ud835\udc65\ud835\udc5c.\ud835\udf11 | (\ud835\udc56,\ud835\udc65)\ud835\udf11\nwhere \ud835\udc4e \u2208 AP, \ud835\udc65 \u2208 X, \ud835\udc56 \u2208 *Agts*, and \ud835\udc5c \u2208 *Obs* is an observation that gets attached to each strategy. SLii is evaluated on CGSs under partial observation, which are pairs (G, {\u223c\ud835\udc5c}\ud835\udc5c\u2208Obs) consisting of a CGS G = (\ud835\udc46,\ud835\udc600, A*,\ud835\udf05, \ud835\udc3f*) and an observation relation \u223c\ud835\udc5c\u2286 \ud835\udc46 \u00d7 \ud835\udc46 for each observation \ud835\udc5c \u2208 *Obs*. If \ud835\udc60 \u223c\ud835\udc5c \ud835\udc60\u2032, then \ud835\udc60 and \ud835\udc60\u2032 appear indistinguishable for a strategy with observation \ud835\udc5c. See Appendix B.3 for the full semantics.\n\nWe can effectively encode each MC instance of SLii into an equisatisfiable HyperSL instance (Note that the MAS models of SLii and HyperSL are different, so we cannot translate the formula directly but translate both the formula and the model).\n\nTheorem 1. For any SLii MC instance \ufffd(G, {\u223c\ud835\udc5c}\ud835\udc5c\u2208Obs),\ud835\udf11\ufffd, we can effectively compute a HyperSL MC instance \ufffdG\u2032,\ud835\udf11\u2032\ufffd, such that\n(G, {\u223c\ud835\udc5c}\ud835\udc5c\u2208Obs) |=SLii \ud835\udf11 iff G\u2032 |= \ud835\udf11\u2032.\n\nProof Sketch. The key observation is that a strategy acting under imperfect information is a hyperproperty [19, 21]: A strategy \ud835\udc53 acts under observation \ud835\udc5c \u2208 *Obs* iff on any two finite paths under \ud835\udc53 the action chosen by \ud835\udc53 is the same, provided the two paths are indistinguishable w.r.t. \u223c\ud835\udc5c. We can extend the CGS G so that the above is easily expressible in HyperSL. We can then restrict quantification to strategies under an arbitrary observation and use a similar translation to the one used in Lemma 1.\n\n\u25a1\nAs model checking of SLii is undecidable [12], we get:\nCorollary 1. Model checking of HyperSL is undecidable.\n"
    },
    {
        "level": "##",
        "title": "6 Model Checking Of Hypersl",
        "content": "\nWhile HyperSL MC is undecidable in general (cf. Corollary 1), we can identify fragments for which MC is possible. For this, we cannot follow the approach of existing MC algorithms for (variants of) nonhyper SL, which use tree automata to summarize strategies [24, 45].\n\nFor example, given an atomic state formula \ud835\udf13 [\ud835\udf0b\ud835\udc58 : \ufffd\ud835\udc65\ud835\udc58]\ud835\udc5a\n\ud835\udc58=1, we cannot construct a tree automaton that accepts all strategies that fulfill\ud835\udf13. This automaton would need to *compare* (and thus traverse)\nmultiple paths in a tree at the same time. Instead - given the \"hyper\" origins of our logic - we approach the MC problem by focusing on the interactions of its path variables and use *word* automata to summarize satisfying path assignments.\n\nThroughout this section, we assume that all strategy variables are \ud835\udefc-renamed such that no variable is quantified more than once.\n"
    },
    {
        "level": "##",
        "title": "6.1 Hypersl[Spe]",
        "content": "\nWe call the fragment of HyperSL we study in this section HyperSL[SPE] - short for HyperSL with Single Path Elimination.\n\nDefinition 1.: _A HyperSL[SPE] formula has the form_\n\n$$\\varphi=\\mathfrak{b}_{1}\\ldots\\mathfrak{b}_{m}.\\,\\psi\\left[\\pi_{k}:\\vec{x}_{k}\\right]_{k=1}^{m},$$\n\n_where $\\mathfrak{b}_{1},\\ldots,\\mathfrak{b}_{m}$ are blocks of strategy quantifiers and for each $1\\leq k\\leq m$ and $i\\in\\mathit{Agts}$, strategy variable $\\vec{x}_{k}(i)$ is quantified in $\\mathfrak{b}_{k}$. We refer to $m$ as the block-rank of $\\varphi$._\nIntuitively, the definition states that we can partition the quantifier prefix into smaller blocks where the variables quantified in each block \u266d\ud835\udc58 can be used to eliminate (construct) the (unique) path variable \ud835\udf0b\ud835\udc58. We will exploit this restriction during model-checking:\nwe can eliminate each block of quantifiers incrementally: as all strategies quantified in block \u266d\ud835\udc58 are only needed for path \ud835\udf0b\ud835\udc58, we can \"construct\" \ud835\udf0b\ud835\udc58, and afterward forget about the strategies we have used. Note that the definition of HyperSL[SPE] only depends on the quantifier prefix and the path each strategy variable is used on; it does not make any assumption on the structure of \ud835\udf13.\n\n**Example 4**.: _Consider the following (abstract) HyperSL formula, where $\\psi$ is an arbitrary LTL formula over $\\pi_{1}$, $\\pi_{2}$._\n\n$$\\underbrace{\\exists c\\cdot\\exists z.\\forall w.\\exists v.\\psi}_{b_{1}}\\left[\\begin{array}{c}\\pi_{1}:(c,c,c,c)\\\\ \\pi_{2}:(w,z,v,v)\\end{array}\\right]$$\n\n_This formula is a HyperSL[SPE] formula: The first block $b_{1}$ consists of strategy variable $c$ and constructs $\\pi_{1}$, and the second block $b_{2}$ constructs $\\pi_{2}$. The block-rank of this formula is 2._\n"
    },
    {
        "level": "##",
        "title": "6.2 Expressiveness Of Hypersl[Spe]",
        "content": "\nBefore we outline our model-checking algorithm for HyperSL[SPE] formulas, we point to some (fragments of) other logics that fall within HyperSL[SPE].\n\nHyperATL\u2217 *and HyperSL[SPE].* When translating HyperATL\u2217 (or HyperATL\u2217\n\ud835\udc46) formulas into HyperSL (cf. Lemmas 2 and 3), each quantifier \u23b7\ud835\udc34\u2304\ud835\udf0b (resp. \ufffd\ud835\udc34\ufffd\ud835\udf0b) is replaced by a \u2203\u2217\u2200\u2217 (resp. \u2200\u2217\u2203\u2217)\nblock of strategy quantifiers that are used to construct \ud835\udf0b (and only\n\ud835\udf0b). The resulting formula is thus a HyperSL[SPE] formula.\n\nSL[1G] and HyperSL[SPE]. SL[1G] is a fragment of SL that allows a prefix of strategy quantifier and agent bindings followed by a single path formula (with no nested agent binding) [23, 45\u201347].\n\nWhen translating SL[1G] into HyperSL, we obtain a formula of the form Q1\ud835\udc651 *. . .* Q\ud835\udc5a\ud835\udc65\ud835\udc5a.\ud835\udf13 [\ud835\udf0b : \ufffd\ud835\udc65] (cf. Lemma 1), which is trivially HyperSL[SPE] as there is a single path variable (with block-rank 1).\n\nBeyond HyperATL\u2217\n\ud835\udc46 *and SL[1G].* Additionally, HyperSL[SPE] captures interesting hyperproperties that could not be captured in existing logics:\n\n**Example 5**.: _Assume a MAS with Apts $=\\{r,a,\\,ndet\\}$ describing a planning task between a robot $r$ that wants to reach a state where AP goal $\\in AP$ holds, and an adversary a that wants to prevent the robot from reaching the goal. In each step, agent $r$ can select a direction to move in, and a can choose a direction it wants to push the robot to. Each combination of actions of $r$ and a results in a set of potential successor locations, and the nondeterminism agent $ndet$ decides which of those locations the robot actually moves to. We want to check if agent $r$ has a winning strategy that can reach the goal against all possible behaviors of agent $a$, i.e., $r$ needs to reach the goal under favorable non-deterministic outcomes. We can express this (non-hyper) property in HyperSL[SPE] as_\n\n$$\\exists x.\\,\\forall y.\\,\\exists z.\\,\\big{(}\\,\\mathbb{F}\\,\\mathit{goal}_{\\pi}\\big{)}\\big{[}\\pi:(x,y,z)\\big{]},$$\n\n_where we write $(x,y,z)$ for the strategy profile that assigns agent $r$ to $x$, agent $a$ to $y$, and agent $ndet$ to $z$. In HyperSL[SPE], we can additionally state that $r$ should reach the goal as fast as possible, i.e., at least as fast as any path in the MAS:_\n\u2203\ud835\udc65. \u2200\ud835\udc66. \u2203\ud835\udc67. \u2200\ud835\udc4e. \u2200\ud835\udc4f. \u2200\ud835\udc50. (\u00acgoal\ud835\udf0b\u2032) U goal\ud835\udf0b\n\n$$\\left[\\begin{array}{l}{\\pi:(x,y,z)}\\\\ {\\pi^{\\prime}:(a,b,c)}\\end{array}\\right]$$\n\nHere, we quantify over any potential different path \ud835\udf0b\u2032 and state that\n\ud835\udf0b is at least as fast as \ud835\udf0b\u2032. Such requirements cannot be expressed in SL\n(even in quantitative versions like SL[F ]), nor can they be expressed\nin HyperATL\u2217 or HyperATL\u2217\n                           \ud835\udc46.\n                                                                   \u25b3\n"
    },
    {
        "level": "##",
        "title": "6.3 Summarizing Path Assignments",
        "content": "\nIn the remainder of this section, we prove the following:\nTheorem 2. Model checking for HyperSL[SPE] is decidable.\n\nWe fix a CGS G = (\ud835\udc46,\ud835\udc600, A*,\ud835\udf05, \ud835\udc3f*) and state \ufffd\ud835\udc60 \u2208 \ud835\udc46, and let \ud835\udf11 =\n\u266d1 . . . \u266d\ud835\udc5a.\ud835\udf13\n\ufffd\n\ud835\udf0b\ud835\udc58 : \ufffd\ud835\udc65\ud835\udc58\n\ufffd\ud835\udc5a\n\ud835\udc58=1 be a HyperSL[SPE] formula. We want to check if \ufffd\ud835\udc60, {} |=G \ud835\udf11, i.e., \ud835\udf11 holds in state \ufffd\ud835\udc60.\n\nZipping Path Assignments. The main idea of our algorithm is to summarize path assignments that satisfy subformulas of \ud835\udf11, similar to MC algorithms for HyperLTL, HyperCTL\u2217, and HyperATL\u2217\n[16\u201318, 33]. To enable automata-based reasoning about path assignments, i.e., mappings \u03a0 : \ud835\udc49 \u2192 \ud835\udc46\ud835\udf14 for some \ud835\udc49 \u2286 V, we *zip* such an assignment into an infinite word. Concretely, given \u03a0 : \ud835\udc49 \u2192 \ud835\udc46\ud835\udf14\nwe define *zip*(\u03a0) \u2208 (\ud835\udc49 \u2192 \ud835\udc46)\ud835\udf14 as the infinite word of functions where *zip*(\u03a0)(\ud835\udc57)(\ud835\udf0b) := \u03a0(\ud835\udf0b)(\ud835\udc57) for every \ud835\udc57 \u2208 N, i.e., the function in the \ud835\udc57th step maps each path variable \ud835\udf0b \u2208 \ud835\udc49 to the \ud835\udc57th state on the path bound to \ud835\udf0b.\n"
    },
    {
        "level": "##",
        "title": "Algorithm 1 Simulation Construction For Block Elimination.",
        "content": "\n1 **def** simulate(G = (\ud835\udc46,\ud835\udc600, A,\ud835\udf05, \ud835\udc3f),\ufffd\ud835\udc60,\ud835\udf0b,\ufffd\ud835\udc65,\u266d = Q1\ud835\udc651 *. . .* Q\ud835\udc5b\ud835\udc65\ud835\udc5b,A):\n\n2\nAdet = (\ud835\udc44,\ud835\udc5e0*,\ud835\udeff,\ud835\udc50*) = toDPA(A) // Using Proposition 1\n3\nB\n= (\ud835\udc44 \u00d7 \ud835\udc46, (\ud835\udc5e0, \ufffd\ud835\udc60),\ud835\udeff\u2032,\ud835\udc50\u2032\ufffd where\n4\n\ud835\udc50\u2032(\ud835\udc5e,\ud835\udc60) := \ud835\udc50 (\ud835\udc5e)\n\ud835\udc56\u2208Agts\n\ud835\udc4e \ufffd\ud835\udc65 (\ud835\udc56)\n\ufffd\ufffd\n\ud835\udc4e\ud835\udc65\ud835\udc5b \u2208A\n\n5\n\ud835\udeff\u2032\ufffd(\ud835\udc5e,\ud835\udc60), \ufffd\ud835\udc61\ufffd :=\n\ud835\udc4e\ud835\udc651 \u2208A\n\u00b7 \u00b7 \u00b7\nQ1\u2228\u2227\nQ\ud835\udc5b\u2228\u2227\n\n\ufffd\n\ud835\udeff \ufffd\ud835\udc5e, \ufffd\ud835\udc61 [\ud835\udf0b \u21a6\u2192 \ud835\udc60]\ufffd,\ud835\udf05\n                    \ufffd\n                     \ud835\udc60,\n                         \ufffd\n\n6\nreturn B\nSummary Automaton. Given a quantifier block \u266d = Q1\ud835\udc651 . . . Q\ud835\udc5b\ud835\udc65\ud835\udc5b\nover strategy variables \ud835\udc651*, . . . ,\ud835\udc65*\ud835\udc5b, we define \ufffd\u266d as the analogous block of quantification of strategies \ud835\udc53\ud835\udc651*, . . . , \ud835\udc53*\ud835\udc65\ud835\udc5b, i.e.,\ufffd\u266d := Q1\ud835\udc53\ud835\udc651 \u2208\nStr(G) . . . Q\ud835\udc5b\ud835\udc53\ud835\udc65\ud835\udc5b \u2208 *Str*(G). At the core of our model-checking algorithm, we construct automata that accept (zippings of) partial satisfying path assignments. Formally:\n\n  Definition 2. For 1 \u2264 \ud835\udc58 \u2264 \ud835\udc5a + 1, we say an automaton A over\nalphabet ({\ud835\udf0b1, . . . , \ud835\udf0b\ud835\udc58\u22121} \u2192 \ud835\udc46) is a (G, \ufffd\ud835\udc60,\ud835\udc58)-summary if for every\npath assignment \u03a0 : {\ud835\udf0b1, . . . , \ud835\udf0b\ud835\udc58\u22121} \u2192 \ud835\udc46\ud835\udf14 we have zip(\u03a0) \u2208 L(A)\nif and only if\n\n\ud835\udc57=\ud835\udc58 |=G \ud835\udf13.\n\n\ud835\udc56\u2208Agts\n          \ud835\udc53\ufffd\ud835\udc65\ud835\udc57 (\ud835\udc56))\n                    \ufffd\ud835\udc5a\n\n\ufffd\n\u266d\ud835\udc58 \u00b7 \u00b7 \u00b7 \ufffd\n   \u266d\ud835\udc5a. \u03a0\n       \ufffd\n       \ud835\udf0b\ud835\udc57 \u21a6\u2192 PlayG(\ufffd\ud835\udc60,\n                 \ufffd\n\n  That is, a (G, \ufffd\ud835\udc60,\ud835\udc58)-summary accepts (the zipping of) a path as-\nsignment \u03a0 over paths \ud835\udf0b1, . . . , \ud835\udf0b\ud835\udc58\u22121 if - when simulating the quan-\ntification over strategies needed to construct paths \ud835\udf0b\ud835\udc58, . . . , \ud835\udf0b\ud835\udc5a and\nadding them to \u03a0 - the body \ud835\udf13 of the formula is satisfied.\n\n  Example 6. We illustrate the concept using the abstract formula\nfrom Example 4. A (G, \ufffd\ud835\udc60, 3)-summary is an automaton A3 over alpha-\nbet ({\ud835\udf0b1, \ud835\udf0b2} \u2192 \ud835\udc46) such that for every \u03a0 : {\ud835\udf0b1, \ud835\udf0b2} \u2192 \ud835\udc46\ud835\udf14 we have\nzip(\u03a0) \u2208 L(A3) iff \u03a0 |=G \ud835\udf13. A (G, \ufffd\ud835\udc60, 2)-summary is an automaton\nA2 over alphabet ({\ud835\udf0b1} \u2192 \ud835\udc46) such that for every \u03a0 : {\ud835\udf0b1} \u2192 \ud835\udc46\ud835\udf14\n\nwe have zip(\u03a0) \u2208 L(A2) iff\n\n\u2203\ud835\udc53\ud835\udc67. \u2200\ud835\udc53\ud835\udc64. \u2203\ud835\udc53\ud835\udc63. \u03a0\n           \ufffd\n           \ud835\udf0b2 \u21a6\u2192 PlayG(\ufffd\ud835\udc60, (\ud835\udc53\ud835\udc64, \ud835\udc53\ud835\udc67, \ud835\udc53\ud835\udc63, \ud835\udc53\ud835\udc63))\n                                \ufffd\n                                 |=G \ud835\udf13,\n\ni.e., we mimic the quantification of block \u266d2 to construct path \ud835\udf0b2 (using\nthe quantified strategies \ud835\udc53\ud835\udc67, \ud835\udc53\ud835\udc64, \ud835\udc53\ud835\udc63 \u2208 Str(G)) and add this path to \u03a0\n(which already contains \ud835\udf0b1).\n                                                                       \u25b3\n"
    },
    {
        "level": "##",
        "title": "6.4 Constructing (G, \ufffd\ud835\udc60,\ud835\udc58)-Summaries",
        "content": "\nWe write \u2228\u2227Q for a conjunction (\ufffd) if Q = \u2200 and a disjunction\n(\ufffd) if Q = \u2203. The backbone of our model-checking algorithm\n(which we present in Section 6.5) is an effective construction of a\n(G, \ufffd\ud835\udc60,\ud835\udc58)-summary A\ud835\udc58 for each 1 \u2264 \ud835\udc58 \u2264 \ud835\udc5a + 1. To construct these summaries, we simulate quantification over strategies. We describe this simulation construction in Algorithm 1. Before explaining the construction, we state the result of Algorithm 1 as follows:\n\n  Proposition 2. Given \ufffd\ud835\udc60 \u2208 \ud835\udc46, \ud835\udf0b \u2208 V, a strategy profile \ufffd\ud835\udc65 : Agts \u2192\nX, a quantifier block \u266d such that for every \ud835\udc56 \u2208 Agts, \ufffd\ud835\udc65(\ud835\udc56) is quantified\nin \u266d, and an APA A over alphabet (\ud835\udc49 \u228e {\ud835\udf0b} \u2192 \ud835\udc46). Let B be the\nresults of simulate(G,\ufffd\ud835\udc60,\ud835\udf0b,\ufffd\ud835\udc65,\u266d,A). Then for any path assignment\n\u03a0 : \ud835\udc49 \u2192 \ud835\udc46\ud835\udf14, we have zip(\u03a0) \u2208 L(B) iff\n\n\ud835\udc56\u2208Agts\n\ud835\udc53\ufffd\ud835\udc65 (\ud835\udc56)\n\ufffd\ufffd\ufffd\n\u2208 L(A).\n(1)\n\ufffd\u266d. zip\n\ufffd\n\u03a0\n\ufffd\n\ud835\udf0b \u21a6\u2192 *Play*G\n\ufffd\ufffd\ud835\udc60,\n\ufffd\nThat is, the automaton B accepts the zipping of an assignment\n\u03a0 : \ud835\udc49 \u2192 \ud835\udc46\ud835\udf14 iff by simulating the quantifier prefix in \u266d, we construct a path for \ud835\udf0b that, when added to \u03a0, is accepted by A. Note the similarity to Definition 2: In Definition 2 we simulate multiple quantifier blocks to construct paths \ud835\udf0b\ud835\udc58*, . . . , \ud835\udf0b*\ud835\udc5a that, when added to\n\u03a0, should satisfy the body \ud835\udf13. In Proposition 2, we simulate a single path that, when added to \u03a0, should be accepted by automaton A.\n\nWe will later use Proposition 2 to simulate one quantifier block at a time, eventually reaching an automaton required by Definition 2.\n\nBefore proving Proposition 2, let us explain the automaton construction in simulate (Algorithm 1). In Eq. (1), \ufffd\u266d quantifies over strategies in G, which are infinite objects (function \ud835\udc46+ \u2192 A). The crucial point that we will exploit is that the underlying game the strategies operate on is *positionally determined*. The automaton we construct can, therefore, *simulate* the path \ud835\udf0b in G and select fresh actions in each step (instead of fixing strategies globally)\n[14, 17, 18]. To do this, we first translate the APA A to a DPA\nAdet = (\ud835\udc44,\ud835\udc5e0*,\ud835\udeff,\ud835\udc50*) (in line 2). The new automaton B then simulates path \ud835\udf0b by tracking its current state in G and simultaneously tracks the current state of Adet, thus operating on states in \ud835\udc44 \u00d7 \ud835\udc46.\n\nWe start in state (\ud835\udc5e0, \ufffd\ud835\udc60), i.e., the initial state of Adet and the designed state \ufffd\ud835\udc60 from which we want to start the simulation of \ud835\udf0b.\n\nThe color of each state is simply the color of the automaton we are tracking, i.e., \ud835\udc50\u2032(\ud835\udc5e,\ud835\udc60) = \ud835\udc50(\ud835\udc5e) (line 4). During each transition, we then update the current state of Adet and the state of the simulation\n(defined in line 5). Concretely, when in state (\ud835\udc5e,\ud835\udc60), we read a letter\n\ufffd\ud835\udc61 : \ud835\udc49 \u2192 \ud835\udc46 that assigns states to all path variables in \ud835\udc49 (recall that the alphabet of A is \ud835\udc49 \u222a {\ud835\udf0b} \u2192 \ud835\udc46 and the alphabet of B is \ud835\udc49 \u2192 \ud835\udc46).\n\nWe update the state of Adet to \ud835\udeff(\ud835\udc5e, \ufffd\ud835\udc61 [\ud835\udf0b \u21a6\u2192 \ud835\udc60]), i.e., we extend the input letter \ufffd\ud835\udc61 with the current state \ud835\udc60 of the simulation of path \ud835\udf0b\n(note that \ufffd\ud835\udc61 [\ud835\udf0b \u21a6\u2192 \ud835\udc60] : \ud835\udc49 \u222a {\ud835\udf0b} \u2192 \ud835\udc46). To update the simulation state \ud835\udc60, we make use of the positional determinacy of the game: Instead of quantifying over strategies (as in Eq. (1)), we can quantify over actions in each step of the automaton. Concretely, for each universally quantified strategy variable in \u266d, we pick an action conjunctively, and for each existentially quantified variable, we pick an action disjunctively. After we have picked actions \ud835\udc4e\ud835\udc651, . . . ,\ud835\udc4e\ud835\udc65\ud835\udc5b\nfor all strategies quantified in \u266d, we can update the state of the\n\ud835\udf0b-simulation by constructing the action assignment \ufffd\n\ud835\udc56\u2208*Agts* \ud835\udc4e \ufffd\ud835\udc65 (\ud835\udc56), i.e., assign each agent the corresponding action, and obtain the next state using G's transition function \ud835\udf05.\n\n  Example 7. Let us use Example 4 to illustrate the construction\nin Algorithm 1. Assume we are given an (G, \ufffd\ud835\udc60, 3)-summary A3 over\nalphabet ({\ud835\udf0b1, \ud835\udf0b2} \u2192 \ud835\udc46), i.e., for every \u03a0 : {\ud835\udf0b1, \ud835\udf0b2} \u2192 \ud835\udc46\ud835\udf14, we\nhave zip(\u03a0) \u2208 L(A3) iff \u03a0 |=G \ud835\udf13 (cf. Example 6). We invoke\nsimulate(G,\ufffd\ud835\udc60,\ud835\udf0b2,\ufffd\ud835\udc65,\u266d2,A3) where \ufffd\ud835\udc65 = (\ud835\udc64,\ud835\udc67, \ud835\udc63, \ud835\udc63) and \u266d2 = \u2203\ud835\udc67\u2200\ud835\udc64\u2203\ud835\udc63,\nand let (\ud835\udc44,\ud835\udc5e0,\ud835\udeff,\ud835\udc50) be the DPA equivalent to A3 (computed in line 2).\nIn this case, simulate computes the APA B = (\ud835\udc44 \u00d7 \ud835\udc46, (\ud835\udc5e0, \ufffd\ud835\udc60),\ud835\udeff\u2032,\ud835\udc50\u2032)\nover alphabet {\ud835\udf0b1} \u2192 \ud835\udc46 where \ud835\udeff\u2032\ufffd(\ud835\udc5e,\ud835\udc60), \ufffd\ud835\udc61\ufffd is defined as\n    \ufffd\n\n\ufffd\n\n\ufffd\n\n\ud835\udc4e\ud835\udc67 \u2208A\n\n\ud835\udc4e\ud835\udc64 \u2208A\n\n\ud835\udc4e\ud835\udc63 \u2208A\n\n\ufffd\n\ud835\udeff(\ud835\udc5e, \ufffd\ud835\udc61 [\ud835\udf0b2 \u21a6\u2192 \ud835\udc60]),\ud835\udf05\ufffd\ud835\udc60, (\ud835\udc4e\ud835\udc64,\ud835\udc4e\ud835\udc67,\ud835\udc4e\ud835\udc63,\ud835\udc4e\ud835\udc63)\ufffd\ufffd\n                                           .\n\nThat is, in each step, we disjunctively choose an action \ud835\udc4e\ud835\udc67 (corre-\nsponding to the action selected by existentially quantified strategy \ud835\udc67),\nconjunctively pick an action \ud835\udc4e\ud835\udc64 (corresponding to the action selected\nby universally quantified strategy \ud835\udc64), and finally disjunctively select\n"
    },
    {
        "level": "##",
        "title": "Algorithm 2 Model-Checking Algorithm For Hypersl[Spe].",
        "content": "\n2\n// Assume \ud835\udf13 contains no nested state formulas\n\n1 def modelCheck(G,\ufffd\ud835\udc60,\ud835\udf11 = \u266d1 \u00b7 \u00b7 \u00b7 \u266d\ud835\udc5a.\ud835\udf13\n                                              \ufffd\n                                               \ud835\udf0b\ud835\udc58 : \ufffd\ud835\udc65\ud835\udc58\n                                                       \ufffd\ud835\udc5a\n                                                        \ud835\udc58=1):\n\n3\nA\ud835\udc5a+1 = LTLtoAPA(\ud835\udf13)\n4\n// A\ud835\udc5a+1 is a (G, \ufffd\ud835\udc60,\ud835\udc5a + 1)-summary\n5\nfor \ud835\udc58 **from** \ud835\udc5a to 1:\n6\nA\ud835\udc58 = simulate(G,\ufffd\ud835\udc60,\ud835\udf0b\ud835\udc58,\ufffd\ud835\udc65\ud835\udc58,\u266d\ud835\udc58,A\ud835\udc58+1)\n7\n// A\ud835\udc58 is a (G, \ufffd\ud835\udc60,\ud835\udc58)-summary\n8\nif L(A1) \u2260 \u2205 then\n9\nreturn SAT // \ufffd\ud835\udc60, {} |=G \ud835\udf11\n10\nelse\n11\nreturn UNSAT\n// \ufffd\ud835\udc60, {} \u0338|=G \ud835\udf11\naction \ud835\udc4e\ud835\udc63. After we have fixed actions \ud835\udc4e\ud835\udc67, \ud835\udc4e\ud835\udc64 and \ud835\udc4e\ud835\udc63, we take a step in G by letting each agent \ud835\udc56 play action \ud835\udc4e \ufffd\ud835\udc65 (\ud835\udc56), i.e., agent 1 chooses action\n\ud835\udc4e\ud835\udc64, agent 2 chooses \ud835\udc4e\ud835\udc67, and agents 3 and 4 pick \ud835\udc4e\ud835\udc63. By Proposition 2, every \u03a0 : {\ud835\udf0b1} \u2192 \ud835\udc46\ud835\udf14 *satisfies zip*(\u03a0) \u2208 L(B) iff\n\u2203\ud835\udc53\ud835\udc67. \u2200\ud835\udc53\ud835\udc64. \u2203\ud835\udc53\ud835\udc63. zip\ufffd\u03a0[\ud835\udf0b2 \u21a6\u2192 PlayG(\ufffd\ud835\udc60, (\ud835\udc53\ud835\udc64, \ud835\udc53\ud835\udc67, \ud835\udc53\ud835\udc63, \ud835\udc53\ud835\udc63))]\ufffd \u2208 L(A3)\nwhich (by assumption on A3) holds iff\n\u2203\ud835\udc53\ud835\udc67. \u2200\ud835\udc53\ud835\udc64. \u2203\ud835\udc53\ud835\udc63. \u03a0[\ud835\udf0b2 \u21a6\u2192 PlayG(\ufffd\ud835\udc60, (\ud835\udc53\ud835\udc64, \ud835\udc53\ud835\udc67, \ud835\udc53\ud835\udc63, \ud835\udc53\ud835\udc63))] |=G \ud835\udf13.\n\nWe have thus used simulate (Algorithm 1) to compute a (G, \ufffd\ud835\udc60, 2)- summary from a (G, \ufffd\ud835\udc60, 3)-summary (cf. Example 6).\n\n\u25b3\nWe can now formally prove Proposition 2:\nProof Sketch of Proposition 2. The idea of automaton B constructed in Algorithm 1 is to simulate the path that corresponds to path variable \ud835\udf0b. To argue that B expresses the desired language, we make use of the positional determinacy of concurrent parity games\n(CPG) [40]. A CPG is a simple multi-player game model where we can quantify over strategies for each of the players. For any fixed \u03a0, we design an (infinite-state) CPG, that is won iff Eq. (1) holds. We then exploit the fact that CPGs are determined (cf. [40, Thm. 4.1]), i.e., instead of quantifying over entire strategies in the CPG, we can quantify over Skolem functions for actions in each step. This allows us to show that the CPG is won iff B has an accepting run (on the fixed \u03a0), giving us the desired result. We refer the interested reader to Appendix D for details.\n\n\u25a1\n"
    },
    {
        "level": "##",
        "title": "6.5 Model-Checking Algorithm",
        "content": "\nEquipped with the concept of (G, \ufffd\ud835\udc60,\ud835\udc58)-summary and the simulation construction, we can now present our MC algorithm for HyperSL[SPE] in Algorithm 2. The modelCheck procedure is given a CGS G, a state \ufffd\ud835\udc60, and a HyperSL[SPE] formula \ud835\udf11, and checks if\n\ufffd\ud835\udc60, {} |=G \ud835\udf11. Our algorithm assumes, w.l.o.g., that the path formula\n\ud835\udf13 contains no nested state formulas. In case there are nested state formulas, we can eliminate them iteratively: We recursively check each nested state formula on all states of the CGS, and label all states where the state formula holds with a fresh atomic proposition. In the path formula, we can then replace each state formula with a reference to the fresh atomic proposition. See, e.g., [18, 31]\nfor details.\n\nThe main idea of our MC algorithm is to iteratively construct a (G, \ufffd\ud835\udc60,\ud835\udc58)-summary A\ud835\udc58 for each 1 \u2264 \ud835\udc58 \u2264 \ud835\udc5a + 1. Initially, in line\n4, we construct a (G, \ufffd\ud835\udc60,\ud835\udc5a + 1)-summary A\ud835\udc5a+1 using a standard\n\n\ud835\udc8f\n|\ud835\udc7a|\n|\ud835\udc7a*reach* |\n\ud835\udc95MCMAS-SL[1G]\n\ud835\udc95HyMASMC\n2\n72\n9\n0.1\n0.4\n3\n432\n21\n6.71\n1.9\n4\n2592\n49\n313.7\n24.5\n5\n15552\n113\nTO\n332.1\n\nconstruction to translate the LTL formula\ud835\udf13 to an APA over alphabet\n({\ud835\udf0b1*, . . . , \ud835\udf0b*\ud835\udc5a} \u2192 \ud835\udc46), as is, e.g., standard for HyperCTL\u2217 [33]. For each \ud835\udc58 from \ud835\udc5a to 1, we then use the (G, \ufffd\ud835\udc60,\ud835\udc58 + 1)-summary A\ud835\udc58+1 to compute a (G, \ufffd\ud835\udc60,\ud835\udc58)-summary A\ud835\udc58 using the simulate construction from Algorithm 1 (similar to what we illustrated in Example 7). From Proposition 2, we can conclude the following invariant:\nLemma 4. In line 7, A\ud835\udc58 is a (G, \ufffd\ud835\udc60,\ud835\udc58)-summary. After the loop, we are thus left with a (G, \ufffd\ud835\udc60, 1)-summary A1\n(over the simpleton alphabet (\u2205 \u2192 \ud835\udc46)) and can check if \ufffd\ud835\udc60, {} |=G \ud835\udf11\nby testing A1 for emptiness (line 8):\nLemma 5. For any (G, \ufffd\ud835\udc60, 1)-summary A*, we have that* L(A) \u2260 \u2205\nif and only if \ufffd\ud835\udc60, {} |=G \ud835\udf11.\n\nFrom Lemmas 4 and 5, it follows that modelCheck(G,\ufffd\ud835\udc60,\ud835\udf11) returns SAT iff \ufffd\ud835\udc60, {} |=G \ud835\udf11, proving Theorem 2.\n"
    },
    {
        "level": "##",
        "title": "6.6 Model-Checking Complexity",
        "content": "\nThe determinization in line 2 of Algorithm 1 results in a DPA Adet of doubly exponential size (cf. Proposition 1). The size of B is then linear in the size of Adet and G. In the worst case, each call of simulate thus increases the size of the automaton by two exponents. For a HyperSL[SPE] formula with block-rank \ud835\udc5a, simulate is called \ud835\udc5a times, so the final automaton A1 has, in the worst case, 2\ud835\udc5a-exponential many states (in the size of \ud835\udf13 and G). As we can check emptiness of APAs over the singleton alphabet (\u2205 \u2192 \ud835\udc46) in polynomial time, we get:\nTheorem 3. Model checking for a HyperSL[SPE] formula with block-rank \ud835\udc5a *is in* 2\ud835\udc5a-EXPTIME.\n\nFrom Lemma 2 and the lower bounds known for HyperATL\u2217\n[17], it follows that our algorithm is asymptotically almost optimal:\nLemma 6. Model checking for a HyperSL[SPE] formula with blockrank \ud835\udc5a is (2\ud835\udc5a \u2212 1)-EXPSPACE-hard.\n"
    },
    {
        "level": "##",
        "title": "6.7 Beyond Hypersl[Spe]",
        "content": "\nHyperSL[SPE] is defined purely in terms of the structure of the quantifier prefix. As soon as strategy variables are quantified in an order such that they cannot be grouped together, MC becomes, in general, undecidable: Already the simplest such property Q\ud835\udc65.Q\ud835\udc66.Q\ud835\udc67.Q\ud835\udc64.\n\n\ud835\udf13 [\ud835\udf0b1 : (\ud835\udc65,\ud835\udc67), \ud835\udf0b2 : (\ud835\udc66,\ud835\udc64)], leads to undecidable MC (see Appendix C.3). The fragment we have identified is thus the largest possible\n(when only considering the quantifier prefix). Any further study into decidable fragments of HyperSL needs to impose restrictions\n\n| Model                 | Sec   | GE   | Rnd   |\n|-----------------------|-------|------|-------|\n| 2                     |       |      |       |\n| Rnd                   |       |      |       |\n| 3                     |       |      |       |\n| Rnd                   |       |      |       |\n| 4                     |       |      |       |\n| bit-transmission      | 0.6   | 0.7  | 0.8   |\n| book-store            | 0.4   | 0.4  | 0.4   |\n| card-game             | 0.4   | 0.5  | 0.4   |\n| dining-cryptographers | 0.6   | 2.7  | 11.4  |\n| muddy-children        | 0.4   | 3.0  | 1.7   |\n| simple-card-game      | 0.3   | 3.4  | 2.9   |\n| software-development  | -     | -    | -     |\n| strongly-connected    | 0.6   | 0.8  | 0.8   |\n| tianji-horse-racing   | 0.4   | 0.5  | 0.4   |\n\nbeyond the prefix and, e.g., analyze how different path variables are related within an LTL path formula (see also Section 8).\n"
    },
    {
        "level": "##",
        "title": "7 Implementation And Experiments",
        "content": "\nWe have implemented our HyperSL[SPE] model-checking algorithm in the HyMASMC tool [18].\n"
    },
    {
        "level": "##",
        "title": "7.1 Model-Checking For Strategy Logic",
        "content": "\nWe compare HyMASMC against MCMAS-SL[1G] [23] on (non-hyper)\nSL[1G] properties (cf. Section 6.2). In Table 1, we depict the verification times for the scheduling problem from [23] (which can be expressed in SL[1G] and ATL\u2217). As in [18], we observe that HyMASMC\nperforms much faster than MCMAS-SL[1G], which we largely accredit to HyMASMC's efficient automata backend using spot [30]. Note that we use MCMAS-SL[1G] and HyMASMC directly on the original model, i.e., we did not perform any prepossessing using, e.g., abstraction techniques [5, 6, 8] (which would reduce the system size and make the verification more scaleable for both tools).\n"
    },
    {
        "level": "##",
        "title": "7.2 Model-Checking For Hyperproperties",
        "content": "\nIn a second experiment, we demonstrate that HyMASMC can verify hyperproperties on various MASs from the literature. We use the ISPL models from the MCMAS benchmarks suit [39], and generate random HyperSL[SPE] formulas from various property templates:\n\n- **(Sec):** We check if some agent \ud835\udc56 can reach some target state\nwithout leaking information about some secret AP via some\nobservable AP. Concretely, we check if \ud835\udc56 can play such that on some other path, the same observation sequence is coupled with a different high-security input, a property commonly referred to\nas *non-inference* [43] or *opacity* [52, 55].\n- **(GE):** We check if a given SL[1G] formula holds on all input\nsequences for which *some* winning output sequence exists, as is, e.g., required in *good-enough* synthesis [1, 3].\n- **(Rnd):** We randomly generate HyperSL[SPE] formulas with blockrank 2, 3, and 4 (called Rnd2, **Rnd**3, and **Rnd**4, respectively).\nWe depict the results in Table 2, demonstrating that HyMASMC\ncan handle most instances. The only exception is the softwaredevelopment model, which includes \u224815k states and is therefore too large for an automata-based representation.\n\nSize\n40\n50\n60\n70\n80\n90\n100\n110\n120\nt\n14.2\n22.0\n31.2\n42.5\n57.6\n70.1\n86.8\n104.6\nTO\n\nWe stress that we do not claim that all formulas in each of the templates model realistic properties in each of the systems. Rather, our evaluation **(1)** demonstrates that HyperSL[SPE] can express interesting properties, and **(2)** empirically shows that HyMASMC can check such properties in existing ISPL models (confirming this via further real-world scenarios is interesting future work).\n"
    },
    {
        "level": "##",
        "title": "7.3 Model-Checking For Optimal Planning",
        "content": "\nIn our last experiment, we challenge HyMASMC with planning examples as those outlined in Example 5. We randomly generate planning instances between the robot \ud835\udc5f, adversary \ud835\udc4e, and *ndet*, and check if robot \ud835\udc5f *can* reach the goal following some shortest path in the problem. For a varying size \ud835\udc5b, we randomly create 10 planning instances with \ud835\udc5b states. We report the verification times in Table 3.\n\nWith increasing size, the running time of HyMASMC clearly increases, but the increase seems to be quadratic rather than exponential.\n"
    },
    {
        "level": "##",
        "title": "8 Conclusion And Future Work",
        "content": "\nWe have presented HyperSL, a new temporal logic that extends strategy logic with the ability to reason about hyperproperties. HyperSL can express complex properties in MASs that require a combination of strategic reasoning and hyper-requirements (such as optimalilty, GE, non-interference, and quantitative Nash equilibria); many of which were out of reach of existing logics. As such, HyperSL can serve as a unifying foundation for an exact exploration of the interaction of strategic behavior with hyperproperties, and provides a formal language to express (un)decidability results. Moreover, we have taken a first step towards the ambitious goal of automatically model-checking HyperSL. Our fragment HyperSL[SPE] subsumes many relevant other logics and captures unique properties not expressible in existing frameworks. Our implementation in HyMASMC\nshows that our MC approach is practical in small MASs.\n\nA particularly interesting future direction is to search for further fragments of HyperSL with decidable model checking. As argued in Section 6.7, any such fragment needs to take the structure of the LTL-formula(s) into account. For example, Mogavero et al. [46] showed that SL[CG] (a fragment of SL that only allows conjunctions of goal formulas) still admits behavioral strategies (i.e., strategies that do not depend on future or counterfactual decisions of other strategies). When extending this to our hyper setting, it seems likely that if a strategy is used on multiple path variables, but these paths occur in disjoint conjuncts of path formulas, MC remains decidable.\n\nWe leave such extensions as future work.\n"
    },
    {
        "level": "##",
        "title": "Acknowledgments",
        "content": "\nThis work was supported by the European Research Council (ERC)\nGrant HYPER (101055412), and by the German Research Foundation\n(DFG) as part of TRR 248 (389792660).\n"
    },
    {
        "level": "##",
        "title": "References",
        "content": "\n[1] Shaull Almagor and Orna Kupferman. 2020. Good-Enough Synthesis. In International Conference on Computer Aided Verification, CAV 2020.\n[2] Rajeev Alur, Thomas A. Henzinger, and Orna Kupferman. 2002. Alternating-time\ntemporal logic. *J. ACM* (2002).\n[3] Benjamin Aminof, Giuseppe De Giacomo, and Sasha Rubin. 2021. Best-Effort\nSynthesis: Doing Your Best Is Not Harder Than Giving Up. In International Joint Conference on Artificial Intelligence, IJCAI 2021.\n[4] Benjamin Aminof, Marta Kwiatkowska, Bastien Maubert, Aniello Murano, and\nSasha Rubin. 2019. Probabilistic Strategy Logic. In International Joint Conference on Artificial Intelligence, IJCAI 2019.\n[5] Thomas Ball and Orna Kupferman. 2006. An Abstraction-Refinement Framework\nfor Multi-Agent Systems. In *Symposium on Logic in Computer Science LICS 2006*.\n[6] Francesco Belardinelli, Angelo Ferrando, Wojciech Jamroga, Vadim Malvone, and\nAniello Murano. 2023. Scalable Verification of Strategy Logic through Three-\nValued Abstraction. In International Joint Conference on Artificial Intelligence,\nIJCAI 2023.\n[7] Francesco Belardinelli, Sophia Knight, Alessio Lomuscio, Bastien Maubert,\nAniello Murano, and Sasha Rubin. 2021. Reasoning About Agents That May\nKnow Other Agents' Strategies. In International Joint Conference on Artificial\nIntelligence, IJCAI 2021.\n[8] Francesco Belardinelli and Alessio Lomuscio. 2017. Agent-based Abstractions\nfor Verifying Alternating-time Temporal Logic with Imperfect Information. In\nConference on Autonomous Agents and MultiAgent Systems, AAMAS 2017.\n[9] Francesco Belardinelli, Alessio Lomuscio, and Vadim Malvone. 2019.\nAn\nAbstraction-Based Method for Verifying Strategic Properties in Multi-Agent\nSystems with Imperfect Information. In Conference on Artificial Intelligence, AAAI 2019.\n[10] Francesco Belardinelli, Alessio Lomuscio, Aniello Murano, and Sasha Rubin.\n2017. Verification of Multi-agent Systems with Imperfect Information and Public\nActions. In Conference on Autonomous Agents and MultiAgent Systems, AAMAS\n2017.\n[11] Rapha\u00ebl Berthon, Bastien Maubert, and Aniello Murano. 2017. Decidability\nResults for ATL* with Imperfect Information and Perfect Recall. In Conference on Autonomous Agents and MultiAgent Systems, AAMAS 2017.\n[12] Rapha\u00ebl Berthon, Bastien Maubert, Aniello Murano, Sasha Rubin, and Moshe Y.\nVardi. 2017. Strategy logic with imperfect information. In Symposium on Logic in\nComputer Science, LICS 2017.\n[13] Rapha\u00ebl Berthon, Bastien Maubert, Aniello Murano, Sasha Rubin, and Moshe Y.\nVardi. 2021. Strategy Logic with Imperfect Information. ACM Trans. Comput.\nLog. (2021).\n[14] Raven Beutner and Bernd Finkbeiner. 2021. A Temporal Logic for Strategic\nHyperproperties. In International Conference on Concurrency Theory, CONCUR 2021.\n[15] Raven Beutner and Bernd Finkbeiner. 2022. Software Verification of Hyperproperties Beyond k-Safety. In International Conference on Computer Aided Verification, CAV 2022.\n[16] Raven Beutner and Bernd Finkbeiner. 2023. AutoHyper: Explicit-State Model\nChecking for HyperLTL. In International Conference on Tools and Algorithms for the Construction and Analysis of Systems, TACAS 2023.\n[17] Raven Beutner and Bernd Finkbeiner. 2023. HyperATL*: A Logic for Hyperproperties in Multi-Agent Systems. *Log. Methods Comput. Sci.* (2023).\n[18] Raven Beutner and Bernd Finkbeiner. 2024. On Alternating-Time Temporal Logic,\nHyperproperties, and Strategy Sharing. In Conference on Artificial Intelligence, AAAI 2024.\n[19] Raven Beutner, Bernd Finkbeiner, Hadar Frenkel, and Niklas Metzger. 2023.\nSecond-Order Hyperproperties. In International Conference on Computer Aided Verification, CAV 2023.\n[20] Patricia Bouyer, Orna Kupferman, Nicolas Markey, Bastien Maubert, Aniello\nMurano, and Giuseppe Perelli. 2019. Reasoning about Quality and Fuzziness of\nStrategic Behaviours. In International Joint Conference on Artificial Intelligence, IJCAI 2019.\n[21] Laura Bozzelli, Bastien Maubert, and Sophie Pinchinat. 2015. Unifying Hyper\nand Epistemic Temporal Logics. In International Conference on Foundations of Software Science and Computation Structures, FoSSaCS 2015.\n[22] Nils Bulling and Wojciech Jamroga. 2014. Comparing variants of strategic ability:\nhow uncertainty and memory influence general properties of games. Auton. Agents Multi Agent Syst. (2014).\n[23] Petr Cerm\u00e1k, Alessio Lomuscio, and Aniello Murano. 2015. Verifying and Synthesising Multi-Agent Systems against One-Goal Strategy Logic Specifications.\nIn *Conference on Artificial Intelligence, AAAI 2015*.\n[24] Krishnendu Chatterjee, Thomas A. Henzinger, and Nir Piterman. 2010. Strategy\nlogic. *Inf. Comput.* (2010).\n[25] Swarat Chaudhuri, Sumit Gulwani, and Roberto Lublinerman. 2012. Continuity\nand robustness of programs. *Commun. ACM* (2012).\n[26] Michael R. Clarkson, Bernd Finkbeiner, Masoud Koleini, Kristopher K. Micinski,\nMarkus N. Rabe, and C\u00e9sar S\u00e1nchez. 2014. Temporal Logics for Hyperproperties.\nIn *International Conference on Principles of Security and Trust, POST 2014*.\n\n[27] Michael R. Clarkson and Fred B. Schneider. 2008. Hyperproperties. In Computer\nSecurity Foundations Symposium, CSF 2008.\n[28] Norine Coenen, Bernd Finkbeiner, Christopher Hahn, and Jana Hofmann. 2019.\nThe Hierarchy of Hyperlogics. In Symposium on Logic in Computer Science, LICS\n2019.\n[29] Catalin Dima and Ferucio Laurentiu Tiplea. 2011. Model-checking ATL under\nImperfect Information and Perfect Recall Semantics is Undecidable. *CoRR* (2011).\n[30] Alexandre Duret-Lutz, Etienne Renault, Maximilien Colange, Florian Renkin,\nAlexandre Gbaguidi Aisse, Philipp Schlehuber-Caissier, Thomas Medioni, Antoine Martin, J\u00e9r\u00f4me Dubois, Cl\u00e9ment Gillard, and Henrich Lauko. 2022. From\nSpot 2.0 to Spot 2.10: What's New?. In International Conference on Computer Aided Verification, CAV 2022.\n[31] E. Allen Emerson and Joseph Y. Halpern. 1986. \"Sometimes\" and \"Not Never\"\nrevisited: on branching versus linear time temporal logic. *J. ACM* (1986).\n[32] Bernd Finkbeiner, Christopher Hahn, Philip Lukert, Marvin Stenger, and Leander Tentrup. 2018. Synthesizing Reactive Systems from Hyperproperties. In\nInternational Conference on Computer Aided Verification, CAV 2018.\n[33] Bernd Finkbeiner, Markus N. Rabe, and C\u00e9sar S\u00e1nchez. 2015. Algorithms for\nModel Checking HyperLTL and HyperCTL*. In International Conference on Computer Aided Verification, CAV 2015.\n[34] Bernd Finkbeiner and Martin Zimmermann. 2017. The First-Order Logic of\nHyperproperties. In Symposium on Theoretical Aspects of Computer Science, STACS 2017.\n[35] Jens Oliver Gutsfeld, Markus M\u00fcller-Olm, and Christoph Ohrem. 2020. Propositional Dynamic Logic for Hyperproperties. In International Conference on Concurrency Theory, CONCUR 2020.\n[36] Sophia Knight and Bastien Maubert. 2019. Dealing with imperfect information\nin Strategy Logic. *CoRR* (2019).\n[37] Fran\u00e7ois Laroussinie and Nicolas Markey. 2015. Augmenting ATL with strategy\ncontexts. *Inf. Comput.* (2015).\n[38] Fran\u00e7ois Laroussinie, Nicolas Markey, and Arnaud Sangnier. 2015. ATLsc with\npartial observation. In International Symposium on Games, Automata, Logics and Formal Verification, GandALF 2015.\n[39] Alessio Lomuscio, Hongyang Qu, and Franco Raimondi. 2009. MCMAS: A Model\nChecker for the Verification of Multi-Agent Systems. In International Conference on Computer Aided Verification, CAV 2009.\n[40] Vadim Malvone, Aniello Murano, and Loredana Sorrentino. 2016. Concurrent\nMulti-Player Parity Games. In International Conference on Autonomous Agents & Multiagent Systems, AAMAS 2016.\n[41] Bastien Maubert and Aniello Murano. 2018. Reasoning about Knowledge and\nStrategies under Hierarchical Information. In International Conference on Principles of Knowledge Representation and Reasoning, KR 2018.\n[42] Daryl McCullough. 1988. Noninterference and the composability of security\nproperties. In *Symposium on Security and Privacy, SP 1988*.\n[43] John McLean. 1994. A general theory of composition for trace sets closed under\nselective interleaving functions. In Symposium on Research in Security and Privacy, SP 1994.\n[44] Satoru Miyano and Takeshi Hayashi. 1984. Alternating Finite Automata on\nomega-Words. *Theor. Comput. Sci.* (1984).\n[45] Fabio Mogavero, Aniello Murano, Giuseppe Perelli, and Moshe Y. Vardi. 2014.\nReasoning About Strategies: On the Model-Checking Problem. ACM Trans. Comput. Log. (2014).\n[46] Fabio Mogavero, Aniello Murano, and Luigi Sauro. 2013. On the Boundary of\nBehavioral Strategies. In *Symposium on Logic in Computer Science, LICS 2013*.\n[47] Fabio Mogavero, Aniello Murano, and Luigi Sauro. 2014. A Behavioral Hierarchy\nof Strategy Logic. In International Workshop on Computational Logic in Multi-\nAgent Systems, CLIMA 2014.\n[48] John F Nash Jr. 1950. Equilibrium points in n-person games. Proceedings of the\nnational academy of sciences (1950).\n[49] Marc Pauly and Rohit Parikh. 2003. Game Logic - An Overview. Stud Logica\n(2003).\n[50] Nir Piterman. 2007. From Nondeterministic B\u00fcchi and Streett Automata to\nDeterministic Parity Automata. *Log. Methods Comput. Sci.* (2007).\n[51] Andrei Sabelfeld. 2003. Confidentiality for Multithreaded Programs via Bisimulation. In International Conference on Perspectives of Systems Informatics, PSI 2003.\n[52] Anooshiravan Saboori and Christoforos N. Hadjicostis. 2013. Verification of\ninitial-state opacity in security applications of discrete event systems. Inf. Sci.\n(2013).\n[53] Moshe Y. Vardi. 1995. Alternating Automata and Program Verification. In\nComputer Science Today: Recent Trends and Developments.\n[54] J. Todd Wittbold and Dale M. Johnson. 1990. Information Flow in Nondeterministic Systems. In *Symposium on Security and Privacy, SP 1990*.\n[55] Kuize Zhang, Xiang Yin, and Majid Zamani. 2019. Opacity of Nondeterministic\nTransition Systems: A (Bi)Simulation Relation Approach. IEEE Trans. Autom.\nControl. (2019).\n"
    },
    {
        "level": "##",
        "title": "A Additional Material For Section 3",
        "content": "\nIn this section we give details on the semantics of APAs. To make our later proofs (which use the APA semantics) easier, we use a DAG-based semantics (opposed to the more prominently used - but equivalent - tree-based semantics). We refer the reader to [53] for more details.\n\nDefinition 3. For a set\ud835\udc44, we write B+(\ud835\udc44) for the set of all positive boolean formulas over \ud835\udc44, i.e., all formulas generated by the grammar\n\n$$\\theta:=q\\mid\\theta_{1}\\wedge\\theta_{2}\\mid\\theta_{1}\\vee\\theta_{2}$$\n\n_where $q\\in Q$. Given a subset $X\\subseteq Q$ and $\\theta\\in\\mathbb{B}^{+}(Q)$, we write $X\\models\\theta$ if the assignment that maps all states in $X$ to $\\top$ and those in $Q\\setminus X$ to $\\bot$ satisfies $\\Psi$. For example $\\{q_{0},q_{1}\\}\\models q_{0}\\wedge(q_{1}\\vee q_{2})$._\nLet A = (\ud835\udc44,\ud835\udc5e0*,\ud835\udeff,\ud835\udc50*) be an APA. A run DAG of A is a pair D = (*\ud835\udc49, \ud835\udc38*) of nodes and edges such that\ud835\udc49 \u2286 \ud835\udc44 \u00d7N, \ud835\udc38 \u2286 \ufffd\n\ud835\udc56\u2208N(\ud835\udc44 \u00d7\n{\ud835\udc56})\u00d7(\ud835\udc44 \u00d7{\ud835\udc56+1}). That is, each node in\ud835\udc49 consist of a state in \ud835\udc44 and a depth and the edges in \ud835\udc38 only reach from depth \ud835\udc56 to depth \ud835\udc56 +1. For every (\ud835\udc5e,\ud835\udc56) \u2208 \ud835\udc49 , we define sucs(\ud835\udc5e,\ud835\udc56) := {\ud835\udc5e\u2032 | ((\ud835\udc5e,\ud835\udc56), (\ud835\udc5e\u2032,\ud835\udc56 + 1)) \u2208 \ud835\udc38}\nas the state component of (\ud835\udc5e,\ud835\udc56)'s successor nodes.\n\nA run of A on a word \ud835\udc62 \u2208 \u03a3\ud835\udf14 is a run DAG D = (*\ud835\udc49, \ud835\udc38*) such that\n(\ud835\udc5e0, 0) \u2208 \ud835\udc49 and for every (\ud835\udc5e,\ud835\udc56) \u2208 \ud835\udc49 , sucs(\ud835\udc5e,\ud835\udc56) |= \ud835\udeff(\ud835\udc5e,\ud835\udc62(\ud835\udc56)). That is, the run DAG starts in the initial state \ud835\udc5e0 at depth 0, and for each node in the DAG the successors of each node satisfy the transition formula given by the transition function \ud835\udeff.\n\nFor example, consider a node (\ud835\udc5e,\ud835\udc56) and assume that \ud835\udeff(\ud835\udc5e,\ud835\udc62(\ud835\udc56)) =\n\ud835\udc5e1 \u2228 \ud835\udc5e2. Then the DAG must include either \ud835\udc5e1 or \ud835\udc5e2 (or both) as successors in the next level. In particular, if the transition function \ud835\udeff uses only disjunctions (no conjunctions) the automataon is non-deterministic. In this case, each node in the DAG can have a unique successor; the DAG is a line (a infinite sequence of states).\n\nConversely, if \ud835\udeff(\ud835\udc5e,\ud835\udc62(\ud835\udc56)) = \ud835\udc5e1 \u2227 \ud835\udc5e2 then both \ud835\udc5e1 and \ud835\udc5e2 need to appear in the next level, i.e., we need to construct accepting runs from both of these states.\n\nA run DAG D is accepting if for every infinite path in the DAG\nthe minimal color that occurs infinitely many times (as given by \ud835\udc50)\nis even. We define L(A) \u2286 \u03a3\ud835\udf14 as all infinite words on which A\nhas an accepting run DAG.\n"
    },
    {
        "level": "##",
        "title": "B Additional Material For Section 5",
        "content": "\nWe provide some background on the temporal logics HyperLTL, SL, HyperATL\u2217, and HyperATL\u2217\n\ud835\udc46 and give their full semantics.\n"
    },
    {
        "level": "##",
        "title": "B.1 Sl And Hypersl",
        "content": "\nIn this subsection, we provide addition details on the relation of SL and HyperSL (cf. Section 5.1). We consider a variant of SL that allows multiple agents to share the strategy by using explicit agent binding, but disallows agent bindings under temporal operators.\n\nRemark 1. The strategy logic by Mogavero et al. [45] allows arbitrary nesting of agent binding within temporal operators. Our variant is equivalent to SL[BG] [45] - a fragment that follows a strict separation between state and path formulas and thereby forbids agent binding under temporal operators. Note that SL[BG] strictly subsumes the strategy logic by Chatterjee et al. [24]. We choose to restrict to the SL[BG] fragment as it is syntactically closer to temporal logics like CTL\u2217 and HyperCTL\u2217 and, thereby, also to HyperSL.\n\nState and path formulas in SL are defined as follows:\n\ud835\udf13 := \ud835\udc4e | \ud835\udf11 | \u00ac\ud835\udf13 | \ud835\udf13 \u2227\ud835\udf13 | X\ud835\udf13 | \ud835\udf13 U\ud835\udf13\n\ud835\udf11 := \ud835\udf13 | \ud835\udf11 \u2227 \ud835\udf11 | \ud835\udf11 \u2228 \ud835\udf11 | \u2200\ud835\udc65.\ud835\udf11 | \u2203\ud835\udc65.\ud835\udf11 | (\ud835\udc56,\ud835\udc65)\ud835\udf11\nwhere \ud835\udc4e \u2208 AP, \ud835\udc65 \u2208 X, and \ud835\udc56 \u2208 *Agts*. Importantly, we assume that every state formula occurring in a path formula is closed.\n\nThe idea of SL is to separate the quantification of a strategy and the binding of a strategy to some agent. To accomplish the latter, it features an explicit agent-binding construct (\ud835\udc56,\ud835\udc65)\ud835\udf11 which evaluates\n\ud835\udf11 after binding agent \ud835\udc56 to strategy \ud835\udc65.\n\nSemantics. Assume G = (\ud835\udc46,\ud835\udc600, A*,\ud835\udf05, \ud835\udc3f*) is a fixed CGS. Given a path \ud835\udc5d \u2208 \ud835\udc46\ud835\udf14 we define the semantics of path formulas as expected:\n\n\ud835\udc5d |=G \ud835\udc4e\niff\n\ud835\udc4e \u2208 \ud835\udc3f(\ud835\udc5d(0))\n\ud835\udc5d |=G \ud835\udf11\niff\n\ud835\udc5d(0), {}, {} |=G \ud835\udf11\n\ud835\udc5d |=G \ud835\udf131 \u2227\ud835\udf132\niff\n\ud835\udc5d |=G \ud835\udf131 and \ud835\udc5d |=G \ud835\udf132\n\ud835\udc5d |=G \u00ac\ud835\udf13\niff\n\ud835\udc5d \u0338|=G \ud835\udf13\n\ud835\udc5d |=G X\ud835\udf13\niff\n\ud835\udc5d[1, \u221e] |=G \ud835\udf13\n\ud835\udc5d |=G \ud835\udf131 U\ud835\udf132\niff\n\u2203\ud835\udc57 \u2208 N. \ud835\udc5d[\ud835\udc57, \u221e] |=G \ud835\udf132 and\n\n\u22000 \u2264 \ud835\udc58 < *\ud835\udc57. \ud835\udc5d*[\ud835\udc58, \u221e] |=G \ud835\udf131\nIn the semantics of state formulas, we keep track of a strategy for each strategy variable via a (partial) strategy assignment \u0394 : X \u21c0\nStr(G), similar to the HyperSL semantics. As SL works with explicit agent bindings, we also keep track of a strategy for each agent using a (partial) function \u0398 : Agts \u21c0 *Str*(G). We can then define:\n\ud835\udc60, \u0394, \u0398 |=G \u2200\ud835\udc65.\ud835\udf11\niff\n\u2200\ud835\udc53 \u2208 *Str*(G).\ud835\udc60, \u0394[\ud835\udc65 \u21a6\u2192 \ud835\udc53 ], \u0398 |=G \ud835\udf11\n\n| \ud835\udc60,   |  \u0394   | ,   |  \u0398   |\n|------|------|-----|------|\n| |    |      |     |      |\n| =    |      |     |      |\n| G    |      |     |      |\n| \u2203    |      |     |      |\n| \ud835\udc65.\ud835\udf11  |      |     |      |\n| iff  |      |     |      |\n| \u2203    |      |     |      |\n| \ud835\udc53    |      |     |      |\n| \u2208    |      |     |      |\n| Str  |      |     |      |\n| (G)  |      |     |      |\n| .\ud835\udc60,  | \u0394    |     |      |\n| [    |      |     |      |\n| \ud835\udc65    |      |     |      |\n| \u21a6\u2192   |      |     |      |\n| \ud835\udc53    |      |     |      |\n| ]    |      |     |      |\n| ,    | \u0398    |     |      |\n| |    |      |     |      |\n| =    |      |     |      |\n| G    |      |     |      |\n| \ud835\udf11    |      |     |      |\n| \ud835\udc60,   | \u0394    | ,   | \u0398    |\n| |    |      |     |      |\n| =    |      |     |      |\n| G    |      |     |      |\n| (    |      |     |      |\n| \ud835\udc56    | ,\ud835\udc65   |     |      |\n| )    |      |     |      |\n| \ud835\udf11    |      |     |      |\n| iff  |      |     |      |\n| \ud835\udc60,   | \u0394    | ,   | \u0398    |\n| [    |      |     |      |\n| \ud835\udc56    |      |     |      |\n| \u21a6\u2192   |      |     |      |\n| \u0394    |      |     |      |\n| (    |      |     |      |\n| \ud835\udc65    |      |     |      |\n| )] | |      |     |      |\n| =    |      |     |      |\n| G    |      |     |      |\n| \ud835\udf11    |      |     |      |\n| \ud835\udc60,   | \u0394    | ,   | \u0398    |\n| |    |      |     |      |\n| =    |      |     |      |\n| G    |      |     |      |\n| \ud835\udf11    |      |     |      |\n| 1    |      |     |      |\n| \u2227    |      |     |      |\n| \ud835\udf11    |      |     |      |\n| 2    |      |     |      |\n| iff  |      |     |      |\n| \ud835\udc60,   | \u0394    | ,   | \u0398    |\n| |    |      |     |      |\n| =    |      |     |      |\n| G    |      |     |      |\n| \ud835\udf11    |      |     |      |\n| 1    |      |     |      |\n| and  |      |     |      |\n| \ud835\udc60,   | \u0394    | ,   | \u0398    |\n| |    |      |     |      |\n| =    |      |     |      |\n| G    |      |     |      |\n| \ud835\udf11    |      |     |      |\n| 2    |      |     |      |\n| \ud835\udc60,   | \u0394    | ,   | \u0398    |\n| |    |      |     |      |\n| =    |      |     |      |\n| G    |      |     |      |\n| \ud835\udf11    |      |     |      |\n| 1    |      |     |      |\n| \u2228    |      |     |      |\n| \ud835\udf11    |      |     |      |\n| 2    |      |     |      |\n| iff  |      |     |      |\n| \ud835\udc60,   | \u0394    | ,   | \u0398    |\n| |    |      |     |      |\n| =    |      |     |      |\n| G    |      |     |      |\n| \ud835\udf11    |      |     |      |\n| 1    |      |     |      |\n| or   |      |     |      |\n| \ud835\udc60,   | \u0394    | ,   | \u0398    |\n| |    |      |     |      |\n| =    |      |     |      |\n| G    |      |     |      |\n| \ud835\udf11    |      |     |      |\n| 2    |      |     |      |\n| \ud835\udc60,   | \u0394    | ,   | \u0398    |\n| |    |      |     |      |\n| =    |      |     |      |\n| G    |      |     |      |\n| \ud835\udf13    |      |     |      |\n| iff  |      |     |      |\n| Play |      |     |      |\n| G    |      |     |      |\n| \ufffd    |      |     |      |\n| \ud835\udc60,   |      |     |      |\n| \ufffd    |      |     |      |\n\n$\\theta$$\\varphi_{1}$ or $s,\\Delta,\\theta$$\\varphi_{\\theta}$$\\prod_{i\\in Agts}\\Theta(i)$$\\varphi_{\\theta}$$\\psi$\n\nStrategy quantification updates the binding in $\\Delta$ (as in HyperSL), whereas strategy binding updates the assignment of agents in $\\Theta$. For each path formula we use the strategy profile $\\Theta$ (mapping each agent to a strategy) to construct the path on which we evaluate $\\psi$. We write $\\mathcal{G}$$\\models_{\\mathrm{SL}}\\varphi$ if $s_{0}$, $\\{\\},\\{\\}$$\\models_{\\mathcal{G}}\\varphi$ in the SL semantics.\n\nEncoding. We can easily encode SL into HyperSL. Instead of using explicit agent bindings as in SL, in HyperSL, each path is annotated with an explicit strategy profile that assigns a strategy\n(variable) to each agent. We assume that in the SL formula no two quantifiers quantify the same strategy variable (which we can always ensure by \ud835\udefc-renaming). Let \ufffd\ud835\udf0b denote some *fixed* path variable. In our translation, we maintain an auxiliary mapping\n\ufffd\ud835\udc65 : *Agts* \u21c0 X mapping agents to strategy variables. We then translate path formulas as follows:\n\n\ufffd\ud835\udc4e\ufffd := \ud835\udc4e \ufffd\ud835\udf0b\n\ufffd\u00ac\ud835\udf13\ufffd := \u00ac\ufffd\ud835\udf13\ufffd\n\ufffd\ud835\udf131 \u2227\ud835\udf132\ufffd := \ufffd\ud835\udf131\ufffd \u2227 \ufffd\ud835\udf132\ufffd\n\ufffd\ud835\udf11\ufffd := \ufffd\ud835\udf11\ufffd{}\n\ufffd X\ud835\udf13\ufffd := X \ufffd\ud835\udf13\ufffd\n\ufffd\ud835\udf131 U\ud835\udf132\ufffd := \ufffd\ud835\udf131\ufffd U \ufffd\ud835\udf132\ufffd\n\nFor state formulas we define:\n\ufffd\ud835\udf111 \u2227 \ud835\udf112\ufffd\ufffd\ud835\udc65 := \ufffd\ud835\udf111\ufffd\ufffd\ud835\udc65 \u2227 \ufffd\ud835\udf112\ufffd\ufffd\ud835\udc65\n\ufffd\ud835\udf111 \u2228 \ud835\udf112\ufffd\ufffd\ud835\udc65 := \ufffd\ud835\udf111\ufffd\ufffd\ud835\udc65 \u2228 \ufffd\ud835\udf112\ufffd\ufffd\ud835\udc65\n\ufffd\u2200\ud835\udc65.\ud835\udf11\ufffd\ufffd\ud835\udc65 := \u2200\ud835\udc65. \ufffd\ud835\udf11\ufffd\ufffd\ud835\udc65\n\ufffd\u2203\ud835\udc65.\ud835\udf11\ufffd\ufffd\ud835\udc65 := \u2203\ud835\udc65. \ufffd\ud835\udf11\ufffd\ufffd\ud835\udc65\n\ufffd\ud835\udf13\ufffd\ufffd\ud835\udc65 := \ufffd\ud835\udf13\ufffd[ \ufffd\ud835\udf0b : \ufffd\ud835\udc65]\n\ufffd(\ud835\udc56,\ud835\udc65)\ud835\udf11\ufffd\ufffd\ud835\udc65 := \ufffd\ud835\udf11\ufffd\ufffd\ud835\udc65 [\ud835\udc56\u21a6\u2192\ud835\udc65 ]\nFor path formulas, we resolve all atomic propositions on the fixed path variable \ufffd\ud835\udf0b. For state formulas, we record the strategy variable played by each agent in the function \ufffd\ud835\udc65, and whenever we reach a path formula, use \ufffd\ud835\udc65 to construct the fixed path \ufffd\ud835\udf0b. Note that the formula resulting from the translation uses boolean combination of state formulas. As already argued in Section 4, we can bring such formulas into the HyperSL syntax by introducing multiple paths\n(see Example 1). We can show that our translation is correct and thus prove Lemma 1:\nLemma 1. For any SL formula \ud835\udf11 there exists a HyperSL formula\n\ud835\udf11\u2032 *such that for any CGS* G, G |=SL \ud835\udf11 *iff* G |= \ud835\udf11\u2032.\n\nProof. We can easily show that for any game structure G and SL formula \ud835\udf11, we have that G |=SL \ud835\udf11 if an only if G |= \ufffd\ud835\udf11\ufffd{}.\n\n\u25a1\nB.2\nHyperATL\u2217 and HyperSL\nIn this subsection, we provide addition details on the relation of HyperATL\u2217 and HyperSL (cf. Section 5.2).\n\nOur hyper variant of strategy logic considers strategies as firstorder objects that can be compared in different strategy profiles.\n\nA weaker form of strategic reasoning is offered in ATL\u2217 [2] by only reasoning about the *outcome* of a strategic interaction. The ATL\u2217 formula \u23b7\ud835\udc34\u2304\ud835\udf13 expresses that the agents in \ud835\udc34 have a joint strategy to enforce that the system follows some path that satisfies\n\ud835\udf13. HyperATL\u2217 [14, 17] is a hyper-variant of ATL that combines strategic reasoning with the ability to express hyperproperties.\n\nSimilar to ATL\u2217, HyperATL\u2217 only considers the outcomes of a strategy but binds this outcome to a path variable which allows comparison w.r.t. a hyperproperty. Formulas in HyperATL\u2217 are generated by the following grammar:\n\n$$\\psi:=a_{\\pi}\\mid\\neg\\psi\\mid\\psi\\wedge\\psi\\mid\\mathsf{X}\\psi\\mid\\psi\\mathsf{U}\\psi$$ $$\\varphi:=\\langle\\!\\langle A\\rangle\\!\\rangle\\pi.\\,\\varphi\\mid\\llbracket A\\rrbracket\\pi.\\,\\varphi\\mid\\psi$$\n\nwhere $a\\in AP$, $\\pi\\in\\mathcal{V}$, and $A\\subseteq\\mathit{Agts}$.\n\n_Semantics_. The semantics of HyperATL${}^{*}$ operates on a path assignment $\\Pi:\\mathcal{V}\\to\\mathcal{S}^{\\omega}$. For path formulas, we follow a similar semantics as used in HyperSL (cf. Section 4):\n\n\u03a0 |=G \ud835\udc4e\ud835\udf0b\niff\n\ud835\udc4e \u2208 \ud835\udc3f(\u03a0(\ud835\udf0b)(0))\n\u03a0 |=G \ud835\udf131 \u2227\ud835\udf132\niff\n\u03a0 |=G \ud835\udf131 and \u03a0 |=G \ud835\udf132\n\u03a0 |=G \u00ac\ud835\udf13\niff\n\u03a0 \u0338|=G \ud835\udf13\n\u03a0 |=G X\ud835\udf13\niff\n\u03a0[1, \u221e] |=G \ud835\udf13\n\u03a0 |=G \ud835\udf131 U\ud835\udf132\niff\n\u2203\ud835\udc57 \u2208 N. \u03a0[\ud835\udc57, \u221e] |=G \ud835\udf132 and\n\u22000 \u2264 \ud835\udc58 < \ud835\udc57. \u03a0[\ud835\udc58, \u221e] |=G \ud835\udf131\n\nFor state formulas, we need to consider all possible outcomes under strategies for a subset of the agents. Given \ud835\udc34 \u2286 *Agts* and strategies\n{\ud835\udc53\ud835\udc56 | \ud835\udc56 \u2208 \ud835\udc34} we define *out* G\n\ufffd\ud835\udc60, {\ud835\udc53\ud835\udc56 | \ud835\udc56 \u2208 \ud835\udc34}\ufffd \u2286 \ud835\udc46\ud835\udf14 as\n\nout G\n     \ufffd\ud835\udc60,{\ud835\udc53\ud835\udc56 | \ud835\udc56 \u2208 \ud835\udc34}\ufffd :=\n       \ufffd\n        PlayG(\ud835\udc60,\n                  \ufffd\n\n\ud835\udc56\u2208Agts\n          \ud835\udc53\ud835\udc56) | \u2200\ud835\udc56 \u2208 Agts \\ \ud835\udc34. \ud835\udc53\ud835\udc56 \u2208 Str(G)\n                                                           \ufffd\n                                                             .\n\nThat is, out G\n              \ufffd\ud835\udc60, {\ud835\udc53\ud835\udc56 | \ud835\udc56 \u2208 \ud835\udc34}\ufffd contains all possible paths compatible\nwith the strategies in {\ud835\udc53\ud835\udc56 | \ud835\udc56 \u2208 \ud835\udc34}. We can then evaluate a state\nformula in the context of a state \ud835\udc60 and path assignment \u03a0.\n\n\ud835\udc60, \u03a0 |=G \ud835\udf13\n                          iff\n                                \u03a0 |=G \ud835\udf13\n\n\ud835\udc60, \u03a0 |=G \u23b7\ud835\udc34\u2304\ud835\udf0b.\ud835\udf11\n                          iff\n                                \u2203{\ud835\udc53\ud835\udc56 | \ud835\udc56 \u2208 \ud835\udc34}.\n\n\u2200\ud835\udc5d \u2208 out G\n       \ufffd\ud835\udc60, {\ud835\udc53\ud835\udc56 | \ud835\udc56 \u2208 \ud835\udc34}\ufffd.\ud835\udc60, \u03a0[\ud835\udf0b \u21a6\u2192 \ud835\udc5d] |=G \ud835\udf11\n\n\ud835\udc60, \u03a0 |=G \ufffd\ud835\udc34\ufffd\ud835\udf0b.\ud835\udf11\n                          iff\n                                \u2200{\ud835\udc53\ud835\udc56 | \ud835\udc56 \u2208 \ud835\udc34}.\n\n\u2203\ud835\udc5d \u2208 out G\n       \ufffd\ud835\udc60, {\ud835\udc53\ud835\udc56 | \ud835\udc56 \u2208 \ud835\udc34}\ufffd.\ud835\udc60, \u03a0[\ud835\udf0b \u21a6\u2192 \ud835\udc5d] |=G \ud835\udf11\n\nThat is, a formula \u23b7\ud835\udc34\u2304\ud835\udf0b.\ud835\udf11 holds when there exist strategies for\nall agents in \ud835\udc34 such that all possible outcomes under those fixed\nstrategies, when bound to \ud835\udf0b, satisfy \ud835\udf11. Likewise, \ufffd\ud835\udc34\ufffd\ud835\udf0b.\ud835\udf11 holds\nwhen all possible strategies admits some path that, when bound\nto \ud835\udf0b, satisfies \ud835\udf11. We write G |=HyperATL\u2217 \ud835\udf11 if \ud835\udc600, {} |=G \ud835\udf11 in the\nHyperATL\u2217 semantics.\n\n  Encoding. Similar to the fact that ATL\u2217 can be encoded in SL\n[24], we can encode HyperATL\u2217 in HyperSL. The idea is to treat\nthe ATL-quantifier \u23b7\ud835\udc34\u2304 as a strategy quantifier that existentially\nquantifies over strategies for agents in \ud835\udc34 and then universally over\nstrategies for agents outside of \ud835\udc34. HyperATL\u2217 path formulas can be\ntranslated verbatim into HyperSL path formulas. To translate state\nformulas we maintain a auxiliary mapping \ud835\udc8d : V \u21c0 XAgts from\npath variables to strategy profiles:\n\n$$\\left(\\left|\\psi\\right|^{I}:=\\psi\\left[\\pi_{1}:I(\\pi_{1}),\\ldots,\\pi_{m}:I(\\pi_{m})\\right]\\right.$$ $$\\left.\\left(\\left|\\left\\langle A\\right\\rangle\\pi.\\varphi\\right|\\right)^{I}:=\\underset{i\\in A}{\\exists}x_{i}.\\quad\\forall\\quad x_{i}.\\quad\\left(\\varphi\\right)^{I}\\left[\\pi\\mapsto\\prod_{i\\in Ag\\mathrm{ts}}x_{i}\\right]\\right.$$ $$\\left.\\left(\\left|\\left[A\\right]\\pi.\\varphi\\right|\\right)^{I}:=\\underset{i\\in A}{\\forall}x_{i}.\\quad\\underset{i\\in Ag\\mathrm{ts}\\setminus A}{\\exists}x_{i}.\\quad\\left(\\varphi\\right)^{I}\\left[\\pi\\mapsto\\prod_{i\\in Ag\\mathrm{ts}\\setminus A}x_{i}\\right]\\right.$$\n\nIn the first case, we assume that $\\pi_{1},\\ldots,\\pi_{m}$ are the path variables used in $\\psi$. In the second and third case, we assume that $x_{1},\\ldots,x_{n}$ are fresh strategy variables for each agent. Intuitively, we replace each $\\left\\langle A\\right\\rangle\\pi$ quantifier with existential quantification over fresh strategies for $A$, followed by universal quantification over strategies for $Ag\\mathrm{ts}\\setminus A$. In the auxiliary mapping $I$, we record which strategy profile we later want to use to construct $\\pi$. For the path formula $\\psi$ we then reconstruct all paths used in the formula using the strategy profiles recorded in $I$. We can use our translation to prove Lemma 2:\nLemma 2. For any HyperATL\u2217 formula \ud835\udf11 there exists a HyperSL\nformula \ud835\udf11\u2032 *such that for any CGS* G, G |=HyperATL\u2217 \ud835\udf11 *iff* G |= \ud835\udf11\u2032.\n\nProof. An easy induction shows that for any game structure G and HyperATL\u2217 formula \ud835\udf11 it holds that G |=HyperATL\u2217 \ud835\udf11 if and only if G |= \ufffd\ud835\udf11\ufffd{}.\n\n\u25a1\n\n  HyperATL\u2217\n          \ud835\udc46. As our translation \ufffd\ud835\udf11\ufffd{} explicitly quantifies over\nstrategies for all agents, we can easily enforce that two agents share\na strategy by simply using the same strategy (variable) for both.\n\nUsing a slight modification of the previous translation, we can thus\nhandle the sharing constraints from HyperATL\u2217\n                                                \ud835\udc46 [18]:\n\n  Lemma 3. For any HyperATL\u2217\n                          \ud835\udc46 formula \ud835\udf11 there exists a HyperSL\nformula \ud835\udf11\u2032 such that for any CGS G, G |=HyperATL\u2217\n                                         \ud835\udc46 \ud835\udf11 iff G |= \ud835\udf11\u2032.\n"
    },
    {
        "level": "##",
        "title": "B.3 Slii And Hypersl",
        "content": "\nIn this subsection, we provide addition details on the relation of SLii and HyperSL (cf. Section 5.3).\n\nSLii [12] extends SL (cf. Section 5.1) by allowing strategies that only observe parts of the system. The formal model of SLii are game structures that are endowed with an observations. Let G =\n(\ud835\udc46,\ud835\udc600, A*,\ud835\udf05, \ud835\udc3f*) be a fixed game structure and let *Obs* be a fixed finite set of so-called *observations*. An observation family {\u223c\ud835\udc5c}\ud835\udc5c\u2208Obs associates an equivalence relation \u223c\ud835\udc5c\u2286 \ud835\udc46 \u00d7 \ud835\udc46 with each \ud835\udc5c \u2208 *Obs*.\n\nFor a strategy with observation \ud835\udc5c, two states \ud835\udc60 \u223c\ud835\udc5c \ud835\udc60\u2032 appear identical. This naturally extends to finite plays: Two finite plays\n\ud835\udc5d, \ud835\udc5d\u2032 \u2208 \ud835\udc46+ are \ud835\udc5c-indistinguishable, written \ud835\udc5d \u223c\ud835\udc5c \ud835\udc5d\u2032, if |\ud835\udc5d| = |\ud835\udc5d\u2032|\nand for each 0 \u2264 \ud835\udc56 < |\ud835\udc5d|, \ud835\udc5d(\ud835\udc56) \u223c\ud835\udc5c \ud835\udc5d\u2032(\ud835\udc56). An \ud835\udc5c*-strategy* is a function\n\ud835\udc53 : \ud835\udc46+ \u2192 A that cannot distinguish between \ud835\udc5c-indistinguishable plays, i.e., for all *\ud835\udc5d, \ud835\udc5d*\u2032 \u2208 \ud835\udc46+ with \ud835\udc5d \u223c\ud835\udc5c \ud835\udc5d\u2032 we have \ud835\udc53 (\ud835\udc5d) = \ud835\udc53 (\ud835\udc5d\u2032). We denote with *Str*(G,\ud835\udc5c) the set of all \ud835\udc5c-strategies in G. We consider SLii formulas that are generated by the following grammar:\n\ud835\udf13 := \ud835\udc4e | \u00ac\ud835\udf13 | \ud835\udf13 \u2227\ud835\udf13 | X\ud835\udf13 | \ud835\udf13 U\ud835\udf13\n\ud835\udf11 := \ud835\udf13 | \ud835\udf11 \u2227 \ud835\udf11 | \ud835\udf11 \u2228 \ud835\udf11 | \u2200\ud835\udc65\ud835\udc5c.\ud835\udf11 | \u2203\ud835\udc65\ud835\udc5c.\ud835\udf11 | (\ud835\udc56,\ud835\udc65)\ud835\udf11\nwhere \ud835\udc4e \u2208 AP, \ud835\udc65 \u2208 X, \ud835\udc56 \u2208 *Agts*, and \ud835\udc5c \u2208 *Obs* is an observation.\n\nCompared to SL, strategy quantification in SLii does not range over arbitrary strategies but over strategies that respect a given observation.\n\nSemantics. The semantics of SL (cf. Appendix B.1) only needs to be changed in the case of strategy quantification:\n\ud835\udc60, \u0394, \u0398 |=G \u2200\ud835\udc65\ud835\udc5c.\ud835\udf11\niff\n\u2200\ud835\udc53 \u2208 Str(G,\ud835\udc5c).\ud835\udc60, \u0394[\ud835\udc65 \u21a6\u2192 \ud835\udc53 ], \u0398 |=G \ud835\udf11\n\ud835\udc60, \u0394, \u0398 |=G \u2203\ud835\udc65\ud835\udc5c.\ud835\udf11\niff\n\u2203\ud835\udc53 \u2208 Str(G,\ud835\udc5c).\ud835\udc60, \u0394[\ud835\udc65 \u21a6\u2192 \ud835\udc53 ], \u0398 |=G \ud835\udf11\nwhere we restrict quantification to \ud835\udc5c-strategies. Given a game structure G, a family {\u223c\ud835\udc5c}\ud835\udc5c\u2208Obs, and an SLii formula \ud835\udf11 we write\n(G, {\u223c\ud835\udc5c}\ud835\udc5c\u2208Obs) |=SLii \ud835\udf11 if \ud835\udc600, {}, {} |=G \ud835\udf11 in the SLii semantics. See\n[12, 13] for concrete examples of SLii.\n\nInjective Labeling and Action Recording. To prove Theorem 1, we need to translate SLii MC instances into equisatisfiable HyperSL\ninstances. In order to translate the model-checking instances, we first modify the underlying game structure. The reason for this is simple: Strategies are defined as functions \ud835\udc46+ \u2192 A and \u223c\ud835\udc5c is defined as a direct relation on states, i.e., both are defined directly on *components of the game structure*. In contrast, *within* our logic, we only observe the evaluation of the atomic propositions. In a first step, we thus modify the game structure provided us with sufficient information within its atomic propositions:\nDefinition 4. A game structure G = (\ud835\udc46,\ud835\udc600, A*,\ud835\udf05, \ud835\udc3f*) is injectively labeled (IL), if \ud835\udc3f : \ud835\udc46 \u2192 2AP is injective, i.e., two labels are equal iff the state is equal. A game structure is action recording (AR) if for each agent \ud835\udc56 \u2208 Agts and every action \ud835\udc4e \u2208 A, there exists an atomic proposition \u27e8\ud835\udc56,\ud835\udc4e\u27e9 \u2208 AP that holds in a state exactly when \ud835\udc56 played\n\ud835\udc56\u2208Agts \ud835\udc4e\ud835\udc56, we have action \ud835\udc4e in the last step. That is, for all \ud835\udc60 \u2208 \ud835\udc46 and all action profile\n\ufffd\n\ud835\udc56\u2208Agts\n{\u27e8\ud835\udc56,\ud835\udc4e\ud835\udc56\u27e9}.\n\n\ud835\udc3f\ufffd\ud835\udf05(\ud835\udc60,\n\ufffd\n\ud835\udc56\u2208Agts\n\ud835\udc4e\ud835\udc56)\ufffd \u2229 {\u27e8\ud835\udc56,\ud835\udc4e\u27e9 | \ud835\udc56 \u2208 *Agts*,\ud835\udc4e \u2208 A} =\n\ufffd\nWe can always ensure that G is injectively labeled by adding at most \u2308log |\ud835\udc46|\u2309 fresh atomic propositions. The evaluation of all formulas (which do not refer to these fresh propositions) remains unchanged when adding such fresh propositions. Similarly, we can always ensure that a structure records actions. This increases the number of states by a factor of |A||*Agts*| but does not increase the branching in the system, nor does it change the semantics of SLii if we extend \u223c\ud835\udc5c to the new states in the obvious way:\n\n  Lemma 7. Given an SLii MC instance (G, {\u223c\ud835\udc5c}\ud835\udc5c\u2208Obs,\ud835\udf11) there\nexists an effectively computable SLii instance (G\u2032, {\u223c\u2032\ud835\udc5c}\ud835\udc5c\u2208Obs,\ud835\udf11\u2032)\nwhere (1) G\u2032 is IL and AR, and (2) (G, {\u223c\ud835\udc5c}\ud835\udc5c\u2208Obs) |=SLii \ud835\udf11 iff\n(G\u2032, {\u223c\u2032\ud835\udc5c}\ud835\udc5c\u2208Obs) |=SLii \ud835\udf11\u2032.\n\nProof. Assume G = (\ud835\udc46,\ud835\udc600, A,\ud835\udf05, \ud835\udc3f). Define AP\u2032 := AP \u228e {\u27e8\ud835\udc56,\ud835\udc4e\u27e9 |\n\n\ud835\udc56 \u2208 Agts,\ud835\udc4e \u2208 A}. We then define\n\n\ud835\udc56\u2208Agts \ud835\udc4e), A,\ud835\udf05\u2032, \ud835\udc3f\u2032)\n\nG\u2032 = (\ud835\udc46 \u00d7 (Agts \u2192 A), (\ud835\udc600, \ufffd\n\nwhere $a\\in\\mathbb{A}$ is some arbitrary action (in the initial state, we do not need to track the last played action). For an action profile $\\prod_{i\\in Agts}a_{i}$, we define $\\kappa^{\\prime}$ and $l^{\\prime}$ by\n\n$$\\kappa^{\\prime}\\left((s,\\_),\\prod_{i\\in Agts}a_{i}\\right):=(\\kappa(s,\\prod_{i\\in Agts}a_{i}),\\prod_{i\\in Agts}a_{i})$$\n\n$$L^{\\prime}(s,\\prod_{i\\in Agts}a_{i}):=L(s)\\uplus\\{\\langle i,a_{i}\\rangle\\mid i\\in Agts\\}.$$\n\ud835\udc56\u2208*Agts* \ud835\udc4e\ud835\udc56 in the second component to set the APs \u27e8\ud835\udc56,\ud835\udc4e\ud835\udc56\u27e9 for all \ud835\udc56 \u2208 *Agts*. We define {\u223c\u2032\ud835\udc5c}\ud835\udc5c\u2208Obs by The idea behind G\u2032 is that we record the action profile that was last used in the second component of each state. In each transition, we ignore the action profile in the current step, and record the new action profile n the second component. In the labeling function, we can then use the action profile \ufffd\n\n\u223c\u2032\n\ud835\udc5c:=\n   \ufffd\ufffd(\ud835\udc60, _), (\ud835\udc60\u2032, _)\ufffd | \ud835\udc60 \u223c\ud835\udc5c \ud835\udc60\u2032\ufffd\n                   .\n\nThat is, for any observation cannot distinguish states based on the\nsecond position. In particular note that (\ud835\udc60, _) and (\ud835\udc60, _) are always\nindistinguishable, i.e., all states we expanded that we added are\nindistinguishable under the new observation.\n  It is easy to see that G\u2032 is AR and that (G, {\u223c\ud835\udc5c}\ud835\udc5c\u2208Obs) |=SLii \ud835\udf11 iff\n(G\u2032, {\u223c\u2032\ud835\udc5c}\ud835\udc5c\u2208Obs) |=SLii \ud835\udf11. Note that we did not change the formula.\nIn a second step, we can ensure that G\u2032 is also IL by simply adding\nsufficiently many new propositions. As those new propositions are\nnever used in \ud835\udf11 the semantics is unchanged.\n                                                                 \u25a1\n\nIdentifying Indistinguishable States.In the next step, we construct a formula that identifies pairs of states that are indistinguishable according to $\\sim_{o}$. For $o\\in Obs$, we define formula $ind_{o}(\\pi_{1},\\pi_{2})$ as follows:\n\n$$\\bigvee_{(s,s^{\\prime})\\in\\sim_{o}}\\left(\\bigwedge_{a\\in L(s)}a_{\\pi}\\wedge\\bigwedge_{a\\in AP\\setminus L(s)}a_{\\pi}\\wedge\\bigwedge_{a\\in L(s^{\\prime})}a_{\\pi^{\\prime}}\\wedge\\bigwedge_{a\\in AP\\setminus L(s^{\\prime})}\\neg a_{\\pi^{\\prime}}\\right)$$\n\nIt is easy to see that on any injectively labeled game structure $ind_{o}(\\pi_{1},\\pi_{2})$ holds if the two paths bound to $\\pi_{1},\\pi_{2}$ are $\\sim_{o}$-related in their first state.\n\nEnforcing Partial Information. Given an observation \ud835\udc5c \u2208 *Obs*, and strategy variable \ud835\udc65, we define a formula *indStrat*\ud835\udc5c (\ud835\udc65) that holds on a strategy iff this strategy is an \ud835\udc5c-strategy (in all reachable situations and for all agents) as follows:\n\n$$\\begin{split}indStrat_{o}(x)&:=\\forall y_{1},\\ldots,y_{n},y^{\\prime}_{1},\\ldots,y^{\\prime}_{n}.\\\\ &\\bigwedge_{i=1}^{n}\\psi^{i}_{o}\\left[\\pi_{1}:(y_{1},\\ldots,y_{i-1},x,y_{i+1},\\ldots,y_{n})\\right]\\\\ &\\pi_{2}:(y^{\\prime}_{1},\\ldots,y^{\\prime}_{i-1},x,y^{\\prime}_{i+1},\\ldots,y^{\\prime}_{n})\\right]\\end{split}$$\n\nwhere\n\n$$\\psi^{i}_{o}:=\\Big{(}\\,\\mathsf{X}\\Big{(}\\bigwedge_{a\\in\\mathbb{A}}\\langle i,a\\rangle_{\\pi_{1}}\\leftrightarrow\\langle i,a\\rangle_{\\pi_{2}}\\Big{)}\\Big{)}\\,\\mathsf{W}\\,\\Big{(}\\neg ind_{o}(\\pi_{1},\\pi_{2})\\Big{)}.$$\n\nThe path formula $\\psi^{i}_{o}$ compares two paths $\\pi_{1},\\pi_{2}$ and states that as long as a prefix on those to paths is $o$-indistinguishable (i.e., $ind_{o}(\\pi_{1},\\pi_{2})$ holds in each step), the action selected by agent $i$ is the same on both paths (using the fact that the structure records actions). As we do not know which agents might end up playing strategy $x$ we assert that $x$ behaves as a $o$-strategy for all agents. For each $i\\in Agts$ we thus compare two paths where $i$ plays $x$, but all other agents play some arbitrary strategy, and assert that $\\psi^{i}_{o}$ holds for those two paths. Strategy $x$ must thus respond to two $o$-indistinguishable prefixes with the same action in all reachable situations for all agents.\n\nThe Translation. Using *indStrat*\ud835\udc5c (\ud835\udc65) as a building block, we can modify the translation of SL into HyperSL from Appendix B.1, and instead translate the much stronger SLii.\n\nTheorem 1. For any SLii MC instance \ufffd(G, {\u223c\ud835\udc5c}\ud835\udc5c\u2208Obs),\ud835\udf11\ufffd, we can effectively compute a HyperSL MC instance \ufffdG\u2032,\ud835\udf11\u2032\ufffd, such that\n(G, {\u223c\ud835\udc5c}\ud835\udc5c\u2208Obs) |=SLii \ud835\udf11 iff G\u2032 |= \ud835\udf11\u2032.\n\nProof. In a first step, we use Lemma 7 to ensure that G is IL\nand AR. We can then translate \ud835\udf11 using a similar translation to the one used in Appendix B.1. The only cases that require changening are the translation of quantification:\n\ufffd\u2200\ud835\udc65\ud835\udc5c.\ud835\udf11\ufffd\ufffd\ud835\udc65 := \u2200\ud835\udc65. *indStrat*\ud835\udc5c (\ud835\udc65) \u2192 \ufffd\ud835\udf11\ufffd\ufffd\ud835\udc65\n\ufffd\u2203\ud835\udc65\ud835\udc5c.\ud835\udf11\ufffd\ufffd\ud835\udc65 := \u2203\ud835\udc65. *indStrat*\ud835\udc5c (\ud835\udc65) \u2227 \ufffd\ud835\udf11\ufffd\ufffd\ud835\udc65\nNote that the resulting formula uses implications between state formulas which is not supported by the HyperSL syntax. It is, however, easy to see that we can push the boolean operations into the path formula as observed in Example 1.\n\nWe claim that for any SLii MC instance (G, {\u223c\ud835\udc5c}\ud835\udc5c\u2208Obs,\ud835\udf11) where G is IL and AR, we have that (G, {\u223c\ud835\udc5c}\ud835\udc5c\u2208Obs) |=SLii \ud835\udf11 iff G |= \ufffd\ud835\udf11\ufffd{}.\n\nTo prove the above we need to argue that *indStrat*\ud835\udc5c (\ud835\udc65) really expresses that \ud835\udc65 is a \ud835\udc5c-strategy. It is easy to see that for any strategy\n\ud835\udc53 \u2208 *Str*(G) we have \ud835\udc60, [\ud835\udc65 \u21a6\u2192 \ud835\udc53 ] |= *indStrat*\ud835\udc5c if and only if \ud835\udc53 is a\n\ud835\udc5c-strategy in all reachable situations from \ud835\udc60. That is, \ud835\udc53 does not necessarily behave as an \ud835\udc5c-strategy in all situations, but at least in those situations that are actually reachable under \ud835\udc53 . As any strategy will only ever be queried on plays that are compatible with the strategy itself, this suffices to encode the SLii semantics.\n\n\u25a1\n"
    },
    {
        "level": "##",
        "title": "C Additional Material For Section 6",
        "content": "\nIn this section we prove the correctness of our HyperSL[SPE] model-checking algorithm (Algorithm 2). Our algorithm hinges on simulate procedure (Algorithm 1) and the resulting properties\n(Proposition 2). We dedicate the entire Appendix D to a proof of Proposition 2, and here focus on the correctness (and complexity) of Algorithm 2.\n"
    },
    {
        "level": "##",
        "title": "C.1 Correctness Proof Of Algorithm 2",
        "content": "\nAs already argued in the main part of the paper, our correctness proof relies on an inductive argument that establishes that we compute (G, \ufffd\ud835\udc60,\ud835\udc58)-summaries for each 1 \u2264 \ud835\udc58 \u2264 \ud835\udc5a + 1.\n\nLemma 4. In line 7, A\ud835\udc58 is a (G, \ufffd\ud835\udc60,\ud835\udc58)-summary.\n\nProof. We show the statement by induction on 1 \u2264 \ud835\udc58 \u2264 \ud835\udc5a + 1\n(from \ud835\udc58 = \ud835\udc5a + 1 to \ud835\udc58 = 1). For the base case (\ud835\udc58 = \ud835\udc5a + 1), we observe that the APA A\ud835\udc5a+1 (computed in line 4) is a (G, \ufffd\ud835\udc60,\ud835\udc5a + 1)-summary.\n\nFor the induction step we can assume - by induction hypothesis \u2013\nthat prior to line 6, A\ud835\udc58+1 is a (G, \ufffd\ud835\udc60,\ud835\udc58+1)-summary. Recall that A\ud835\udc58+1\nis an APA over ({\ud835\udf0b1*, . . . \ud835\udf0b*\ud835\udc58} \u2192 \ud835\udc46) and A\ud835\udc58 over ({\ud835\udf0b1*, . . . \ud835\udf0b*\ud835\udc58\u22121} \u2192\n\ud835\udc46). We claim that A\ud835\udc58 is a (G, \ufffd\ud835\udc60,\ud835\udc58)-summary. To show this, take any\n\u03a0 : {\ud835\udf0b1*, . . . \ud835\udf0b*\ud835\udc58\u22121} \u2192 \ud835\udc46\ud835\udf14 and we need to show that (cf. Definition 2\nof (G, \ufffd\ud835\udc60,\ud835\udc58)-summary) *zip*(\u03a0) \u2208 L(A\ud835\udc58) if and only if\n\ud835\udc57=\ud835\udc58 |=G \ud835\udf13.\n\n\ud835\udc56\u2208Agts\n\ud835\udc53\ufffd\ud835\udc65\ud835\udc57 (\ud835\udc56)\n\ufffd\ufffd\ud835\udc5a\n\n\ufffd\n\u266d\ud835\udc58 \u00b7 \u00b7 \u00b7 \ufffd\n   \u266d\ud835\udc5a. \u03a0\n       \ufffd\n       \ud835\udf0b\ud835\udc57 \u21a6\u2192 PlayG\n               \ufffd\ufffd\ud835\udc60,\n                 \ufffd\n\nBy adding parenthesis, the latter holds if and only if\n\n\ud835\udc57=\ud835\udc58 |=G \ud835\udf13\n                \ufffd\n\n\ud835\udc56\u2208Agts\n          \ud835\udc53\ufffd\ud835\udc65\ud835\udc57 (\ud835\udc56)\n                   \ufffd\ufffd\ud835\udc5a\n\n\ufffd\n\u266d\ud835\udc58.\n \ufffd\n  \ufffd\n  \u266d\ud835\udc58+1 \u00b7 \u00b7 \u00b7 \ufffd\n       \u266d\ud835\udc5a. \u03a0\n          \ufffd\n           \ud835\udf0b\ud835\udc57 \u21a6\u2192 PlayG\n                   \ufffd\ufffd\ud835\udc60,\n                     \ufffd\n\nwhich holds if and only if\n\n\ud835\udc57=\ud835\udc58+1 |=G \ud835\udf13\n                    \ufffd\n\n\ud835\udc56\u2208Agts\n          \ud835\udc53\ufffd\ud835\udc65\ud835\udc57 (\ud835\udc56)\n                   \ufffd\ufffd\ud835\udc5a\n\n\ufffd\n\u266d\ud835\udc58.\n \ufffd\n  \ufffd\n  \u266d\ud835\udc58+1 \u00b7 \u00b7 \u00b7 \ufffd\n       \u266d\ud835\udc5a. \u03a0\u2032\ufffd\n           \ud835\udf0b\ud835\udc57 \u21a6\u2192 PlayG\n                   \ufffd\ufffd\ud835\udc60,\n                      \ufffd\n\n                                                     \ud835\udc56\u2208Agts \ud835\udc53\ufffd\ud835\udc65\ud835\udc58 (\ud835\udc56)\n                                                                        \ufffd\ufffd\n                                                                            . By the assumption\nthat A\ud835\udc58+1 is a (G, \ufffd\ud835\udc60,\ud835\udc58 + 1)-summary we can replace the inner part\nand get that the above is equivalent to\n\nwhere \u03a0\u2032 = \u03a0[\ud835\udf0b\ud835\udc58 \u21a6\u2192 PlayG\n                      \ufffd\ufffd\ud835\udc60, \ufffd\n\nAfter unfolding the definition of \u03a0\u2032, this becomes\n\n\ufffd\n\u266d\ud835\udc58.zip(\u03a0\u2032) \u2208 L(A\ud835\udc58+1).\n\n\ud835\udc56\u2208Agts\n          \ud835\udc53\ufffd\ud835\udc65\ud835\udc58 (\ud835\udc56)\n                   \ufffd\ufffd\ufffd\n                         \u2208 L(A\ud835\udc58+1).\n\n\ufffd\n\u266d\ud835\udc58. zip\n   \ufffd\n    \u03a0\n     \ufffd\n      \ud835\udf0b\ud835\udc58 \u21a6\u2192 PlayG\n              \ufffd\ufffd\ud835\udc60,\n                \ufffd\n\nNow recall that we defined A\ud835\udc58 = simulate(G,\ufffd\ud835\udc60,\ud835\udf0b\ud835\udc58,\ufffd\ud835\udc65\ud835\udc58,\u266d\ud835\udc58,A\ud835\udc58+1).\nBy Proposition 2 we now have that the above holds iff\n\nzip(\u03a0) \u2208 L(A\ud835\udc58).\n\nas required.\n                                                                 \u25a1\n\n  Lemma 5. For any (G, \ufffd\ud835\udc60, 1)-summary A, we have that L(A) \u2260 \u2205\nif and only if \ufffd\ud835\udc60, {} |=G \ud835\udf11.\n\nProof. Note that the alphabet of $\\mathcal{A}$ is the singleton set $(\\emptyset\\to S)$. We thus get that $\\mathcal{L}(\\mathcal{A})\\neq\\emptyset$ iff $\\mathit{zip}(\\{\\})\\in\\mathcal{L}(\\mathcal{A})$ where $\\{\\}$ is the unique path assignment $\\emptyset\\to S^{\\omega}$ so $\\mathit{zip}(\\{\\})$ is the unique word over $(\\emptyset\\to S)$. Now by Definition 2 we have that $\\mathit{zip}(\\{\\})\\in\\mathcal{L}(\\mathcal{A})$ iff\n\n$$\\tilde{b}_{1}\\cdots\\tilde{b}_{m}.\\,\\{\\}\\Big{[}\\pi_{j}\\mapsto\\mathit{Play}_{\\mathcal{G}}(\\dot{s},\\prod_{i\\in\\mathit{Alg}_{\\mathcal{G}}(i)}f_{\\tilde{\\pi}_{j}(i)})\\Big{]}_{j=1}^{m}\\models_{\\mathcal{G}}\\psi$$ where we add all paths to the empty path assignment $\\{\\}$. As we add to the empty path assignment, the above is thus equivalent to\n\n$$\\widetilde{b}_{1}\\cdots\\widetilde{b}_{m}\\cdot\\left[\\pi_{j}\\mapsto\\mathit{Play}_{\\mathcal{G}}\\left(\\dot{s},\\prod_{i\\in\\mathit{Alg}_{\\mathcal{B}}^{\\mathrm{r}}}f_{\\widehat{x}_{j}\\left(i\\right)}\\right)\\right]_{j=1}^{m}\\models_{\\mathcal{G}}\\psi$$\n\nwhich exactly expresses $\\dot{s}$, $\\{\\}\\models_{\\mathcal{G}}\\varphi$ in the HyperSL semantics.\n"
    },
    {
        "level": "##",
        "title": "C.2 Model-Checking Complexity",
        "content": "\nTheorem 3. Model checking for a HyperSL[SPE] formula with block-rank \ud835\udc5a *is in* 2\ud835\udc5a-EXPTIME.\n\nProof. Each time we invoke simulate (Algorithm 1) the automaton size increases by two exponents. A formula with block-rank \ud835\udc5a requires \ud835\udc5a applications of simulate (cf. Algorithm 2), so the final automaton A1 has size that is 2\ud835\udc5a-times exponential in the size of\n\ud835\udf13 and G. Automaton A1 operates on a singleton alphabet (\u2205 \u2192 \ud835\udc46), so we can decide its emptiness in polynomial time. Model checking is thus in 2\ud835\udc5a-EXPTIME in the size of \ud835\udf13 and G.\n\n\u25a1\nLemma 6. Model checking for a HyperSL[SPE] formula with blockrank \ud835\udc5a is (2\ud835\udc5a \u2212 1)-EXPSPACE-hard.\n\nProof. For HyperATL\u2217 it is known that checking a formula with \ud835\udc5a quantifiers is (2\ud835\udc5a \u2212 1)-EXPSPACE-hard (in the size of the formula) [17, Thm. 7.1 and 7.2]. As the translation of a HyperATL\u2217\nformula with \ud835\udc5a qunatifiers into a HyperSL[SPE] formula is linear\n(cf. Lemma 2 and Appendix B.2) and yields a formula with blockrank \ud835\udc5a, the lower bound follows.\n\n\u25a1\n"
    },
    {
        "level": "##",
        "title": "C.3 Beyond Hypersl[Spe]",
        "content": "\nAs we argued in Section 6.7, any HyperSL formula where the prefix cannot be grouped into blocks as in Definition 1, MC becomes in general undecidable.\n\nLemma 8. Model checking for a HyperSL formula of the form\n\u2203\ud835\udc65.\u2203\ud835\udc66.\u2200\ud835\udc67.\u2200\ud835\udc64.\ud835\udf13\n\ufffd\ud835\udf0b1 : (\ud835\udc65,\ud835\udc67)\n\ufffd\n\ud835\udf0b2 : (\ud835\udc66,\ud835\udc64)\nis, in general, undecidable.\n\nProof. We encode the HyperLTL realizability problem of a \u22002\n\nformula, which is known to be undecidable [32]. Given a HyperLTL formula $\\varphi=\\forall\\pi_{1}.\\forall\\pi_{2}.\\psi$ over $I\\upharpoonright O$ we define\n\n$$\\psi^{\\prime}:=\\psi\\wedge\\left(\\left(\\chi\\left(\\bigwedge_{\\alpha\\in\\mathcal{O}}a_{\\pi_{1}}\\leftrightarrow a_{\\pi_{2}}\\right)\\right)\\mathsf{W}\\left(\\bigvee_{\\alpha\\in I}a_{\\pi_{1}}\\leftrightarrow a_{\\pi_{2}}\\right)\\right)$$\n\nThat is, the two paths $\\pi_{1},\\pi_{2}$ should satisfy $\\psi$ and, in addition, when given the same sequence of inputs, the output should be the same. We claim that $\\varphi=\\forall\\pi_{1}.\\forall\\pi_{2}.\\psi$ is realizable if and only if\n\n$$\\mathcal{G}_{(I,O)}\\models\\exists x.\\exists y.\\forall z.\\forall w.\\,\\psi^{\\prime}\\begin{bmatrix}\\pi_{1}:(x,z)\\\\ \\pi_{2}:(y,w)\\end{bmatrix}$$\n\nwhere $\\mathcal{G}_{(I,O)}$ is the CGS in which agent $1$ can set the inputs $I$ and agent $2$ can set the outputs $O$ (see, e.g., [2]). The intuition is that the additional conjunct requires that the two strategies bound to $x$ and $y$ denote the _same_ strategy. The above formula thus states that there exists some strategy that controls the outputs such that all pairs of traces under that strategy satisfy $\\psi$. Deciding the existence of such a strategy is undecidable [32], so we get the desired result.\n"
    },
    {
        "level": "##",
        "title": "D Proof Of Proposition 2",
        "content": "\nIn this section, we prove Proposition 2:\n\nProposition 2: _Given $\\delta\\in S,\\pi\\in\\mathcal{V}$, a strategy profile $\\vec{x}:\\mathit{Apts}\\to\\mathcal{X}$, a quantifier block $\\mathfrak{b}$ such that for every $i\\in\\mathit{Apts},\\vec{x}(i)$ is quantified in $\\mathfrak{b}$, and an APA $\\mathcal{A}$ over alphabet $(V\\upharpoonright\\pi)\\to S)$. Let $\\mathcal{B}$ be the results of $\\mathit{simulate}(\\mathcal{G},\\delta,\\pi,\\vec{x},\\mathfrak{b},\\mathcal{A})$. Then for any path assignment $\\Pi:V\\to S^{\\omega}$, we have $\\mathit{zip}(\\Pi)\\in\\mathcal{L}(\\mathcal{B})$ iff_\n\n$$\\widetilde{\\mathfrak{b}}.\\mathit{zip}\\Big{(}\\Pi\\big{[}\\pi\\mapsto\\mathit{Play}_{\\mathcal{G}}(\\delta,\\prod_{i\\in\\mathit{Apts}}f_{\\vec{x}(i)})\\big{]}\\Big{)}\\in\\mathcal{L}(\\mathcal{A}).\\tag{1}$$\n\nFor any $m\\in\\mathbb{N}$, we define $[m]:=\\{1,\\ldots,m\\}$. To make the proof of its correctness easier, we assume that\n\n$$\\mathfrak{b}=\\forall1.\\exists2.\\forall3\\ldots\\exists2m.\\tag{2}$$\n\nThat is, we assume that the strategy variables are number in $[2m]$. And, moreover, we assume the quantifier block alternates strictly in every step: odd strategy variables (numbers) are universally quantified and even variables are existentially quantified. Note that this assumption is w.l.o.g., we can always add quantification over additional strategy variables that wil never be used for the construction of $\\pi$. Having a fixed alternation makes formal reasoning and notation easier.\n\nThe Candidate. Let Adet = (\ud835\udc44,\ud835\udc5e0*,\ud835\udeff,\ud835\udc50*) be the DPA constructed from A in line 2 of Algorithm 1 (using Proposition 1). Following the construction in Algorithm 1, we get that B (the result of simulate(G,\ufffd\ud835\udc60,\ud835\udf0b,\ufffd\ud835\udc65,\u266d,A)) satisfies B = \ufffd\ud835\udc44 \u00d7 \ud835\udc46, (\ud835\udc5e0, \ufffd\ud835\udc60),\ud835\udeff\u2032,\ud835\udc50\u2032\ufffd, where \ud835\udc50\u2032(\ud835\udc5e,\ud835\udc60) := \ud835\udc50(\ud835\udc5e), and for \ufffd\ud835\udc61 \u2208 \ud835\udc46\ud835\udc49 , \ud835\udeff\u2032\ufffd(\ud835\udc5e,\ud835\udc60), \ufffd\ud835\udc61\ufffd is defined as as\n\ufffd\n\ufffd\n\ud835\udc4e1\u2208A\n\ud835\udc4e2\u2208A\n\u00b7 \u00b7 \u00b7\n\ufffd\n\ud835\udc4e2\ud835\udc5a \u2208A\n\n\ud835\udc56\u2208Agts\n         \ud835\udc4e \ufffd\ud835\udc65 (\ud835\udc56)\n                  \ufffd\ufffd\n                     ,\n\n\ufffd\n\ud835\udeff \ufffd\ud835\udc5e, \ufffd\ud835\udc61 [\ud835\udf0b \u21a6\u2192 \ud835\udc60]\ufffd,\ud835\udf05\ufffd\ud835\udc60,\n                        \ufffd\n\nWith this construction fixed, it remains to argue that it accepts the\ndesired language. Expressed as a lemma:\n\n**Lemma 9**.: _For any path assignment $\\Pi:V\\to S^{\\omega}$ we have $zip(\\Pi)\\in\\mathcal{L}(\\mathcal{B})$ if and only if_\n\n$$\\widetilde{b}.\\,zip\\Big{(}\\Pi\\big{[}\\pi\\mapsto\\mathit{Play}_{\\mathcal{G}}(\\dot{s},\\prod_{i\\in\\mathcal{A}_{\\mathcal{B}}^{\\mathrm{c}}\\mathrm{rs}}f_{\\widetilde{x}(i)})\\big{]}\\Big{)}\\in\\mathcal{L}(\\mathcal{A}).\\tag{3}$$\n\nThe main prove idea in showing that B accepts the language desired by Proposition 2, goes via the determinacy of concurrent parity games.\n\n  Definition 5 (Concurrent Parity Game). A concurrent parity\ngame (CPG) is a a tuple P = (\ud835\udc49, \ud835\udc630, A,\ud835\udc5a, \ud835\udf07,\ud835\udc50) where \ud835\udc49 is a (possibly\ninfinite) set of vertices, \ud835\udc630 \u2208 \ud835\udc49 is an initial vertex, A is a finite set of\nactions, \ud835\udc5a \u2208 N gives the number of alternations (so 2\ud835\udc5a is the number\nof player), \ud835\udf07 : \ud835\udc49 \u00d7 ([2\ud835\udc5a] \u2192 A) \u2192 \ud835\udc49 is a transition function, and\n\ud835\udc50 : \ud835\udc49 \u2192 \ud835\udc36 is a coloring for some finite \ud835\udc36 \u2286 N.\n\n  We refer to the protagonist in CPGs as players to distinguish\nthem from the agents in a game structure. Similar to the simplyfying\nassumption we made of \u266d, we will later quantify universally over\nstrategies for odd players and existentially for even players. A\nstrategy in P is a function \ud835\udc53 : \ud835\udc49 + \u2192 A and we write Str(P)\n\nfor the set of all strategies in P. When given a strategy profile\n\ufffd\ud835\udc53 : [2\ud835\udc5a] \u2192 Str(P) assigning a strategy for each player, and a\nvertex \ud835\udc63 \u2208 \ud835\udc49 , we define PlayP (\ud835\udc63, \ufffd\ud835\udc53 ) \u2208 \ud835\udc49 \ud835\udf14 as the unique play\n\ud835\udc5d \u2208 \ud835\udc49 \ud835\udf14 such that \ud835\udc5d(0) = \ud835\udc63, and for every \ud835\udc57 \u2208 N, \ud835\udc5d(\ud835\udc57 + 1) =\n\ud835\udf07\ufffd\ud835\udc5d(\ud835\udc57), \ufffd\n          \ud835\udc59 \u2208[2\ud835\udc5a] \ufffd\ud835\udc53 (\ud835\udc59)(\ud835\udc5d[0, \ud835\udc57])\ufffd (similar to the definition in CGSs,\ncf. Section 3). We say an infinite play \ud835\udc5d \u2208 \ud835\udc49 \ud835\udf14 is even if the minimal\ncolor that occurs infinity many times (as given by \ud835\udc50) is even. In this\ncase we write even(\ud835\udc5d).\n\nDefinition 6. The CPG P is won by the existential team if\n\n$\\forall f_{1}\\in Str(\\mathcal{P}).\\exists f_{2}\\in Str(\\mathcal{P}).\\forall f_{3}\\in Str(\\mathcal{P})\\dots\\exists f_{2m}\\in Str(\\mathcal{P}).$\n\n$$\\text{even}\\Big{(}\\text{Play}_{\\mathcal{P}}(v_{0},\\prod_{l\\in[2m]}f_{l})\\Big{)}.$$\n\nThat is we quantify over strategies in $\\mathcal{P}$ for all player $l\\in[2m]$; universally for odd player and existentially for even player in alternating fashion. The game is won (by the existential team) if the existential quantifier can ensure that the resulting play is even.\n\nD.2\nConstruction of P\u03a0\nAssume we are given a fixed strategy assignment \u03a0 : \ud835\udc49 \u2192 \ud835\udc46\ud835\udf14. We design an infinite-state CPG P\u03a0 as P\u03a0 = (\ud835\udc44 \u00d7 \ud835\udc46 \u00d7 N, (\ud835\udc5e0, \ufffd\ud835\udc60, 0), A*,\ud835\udc5a, \ud835\udf07,\ud835\udc50*\u2032)\n\ud835\udc56\u2208Agts\n\ufffd\ud835\udc4e(\ufffd\ud835\udc65(\ud835\udc56))\ufffd, \ud835\udc41 + 1\n\ufffd\n\nwhere \ud835\udc44 is the set of states in Adet, \ud835\udc50\u2032(\ud835\udc5e,\ud835\udc60, \ud835\udc41) := \ud835\udc50(\ud835\udc5e) and for each\naction profile \ufffd\ud835\udc4e : [2\ud835\udc5a] \u2192 A we define \ud835\udf07\ufffd(\ud835\udc5e,\ud835\udc60, \ud835\udc41), \ufffd\ud835\udc4e\ufffd as\n     \ufffd\n      \ud835\udeff \ufffd\ud835\udc5e, zip(\u03a0)(\ud835\udc41)[\ud835\udf0b \u21a6\u2192 \ud835\udc60]\ufffd,\ud835\udf05\ufffd\ud835\udc60,\n                               \ufffd\n\nIn the following we abbreviate \ud835\udc49 := \ud835\udc44 \u00d7 \ud835\udc46 \u00d7 N for the vertices in\nP\u03a0, and define \ud835\udc630 := (\ud835\udc5e0, \ufffd\ud835\udc60, 0) as the initial vertex of P\u03a0.\n  Let us discuss the construction of P\u03a0. Actions in P\u03a0 are the\nsame as in G (i.e., A). For each quantified strategy variable 1, . . . , 2\ud835\udc5a\n(cf. Equation (2)), we have a corresponding player in P\u03a0 (i.e., there\nare \ud835\udc5a alternations, so the set of players is [2\ud835\udc5a]). We operate on\nvertices (\ud835\udc5e,\ud835\udc60, \ud835\udc41), where \ud835\udc5e \u2208 \ud835\udc44 and \ud835\udc60 \u2208 \ud835\udc46 are similar to the construc-\ntion of B. In addition we track the current step \ud835\udc41. To update \ud835\udc5e we\ninvoke the transition function \ud835\udeff of Adet on the current automaton\nstate and letter zip(\u03a0)(\ud835\udc41)[\ud835\udf0b \u21a6\u2192 \ud835\udc60]. Note that this corresponds to\nthe input of B: B reads the zipping of a strategy assignment \u03a0 as\nan input and thus the \ud835\udc41th letter of the input is zip(\u03a0)(\ud835\udc41). That is,\nwe \"hardcode\" \u03a0 into the game. For this, we maintain the current\nstep via counter \ud835\udc41 and \"pretend\" the input in the \ud835\udc41th step was\nzip(\u03a0)(\ud835\udc41). Similar to B, we update the automaton state by pass-\ning zip(\u03a0)(\ud835\udc41)[\ud835\udf0b \u21a6\u2192 \ud835\udc60] to Adet's transition function. To update\nthe state of the simulation of G we proceed as in B, i.e., given a\nfunction \ufffd\ud835\udc4e : [2\ud835\udc5a] \u2192 A that fixes actions for all strategy variables\n(or, equivalently, players in P\u03a0), each agent \ud835\udc56 \u2208 Agts will simply\nplay the action assigned to strategy variable \ufffd\ud835\udc65(\ud835\udc56), i.e., \ufffd\ud835\udc4e(\ufffd\ud835\udc65(\ud835\udc56)).\n  The idea of P\u03a0 is to serve as intermediate representation be-\ntween the target language (Eq. (3)) and the definition of B. In the\nsemantics of CPGs the quantification over strategies for the players\noccurs \"outside\", i.e., strategies are fixed globally (cf. Definition 6).\nAs players in P\u03a0 correspond exactly to the strategy variables used\nin \u266d ([2\ud835\udc5a]), this \"outer\" quantification mimics the quantification\nfound in Eq. (3). On the other hand, the updates of automaton and\nsystem state in P\u03a0 are similar to the updates performed in B.\n"
    },
    {
        "level": "##",
        "title": "D.3 The First Implication",
        "content": "\nAs a first step, we will show that P\u03a0 is won by the existential player if and only \u03a0 satisfies Eq. (3). This step is easy: The quantification in P\u03a0 and Eq. (3) is very similar (i.e., occurs \"outside\" the game).\n\nWe can, therefore, transfer strategies between G and P\u03a0 as follows:\nLemma 10. The following holds:\n\n* _For any_ $\\Delta:[2m]\\to\\mathit{Str}(\\mathcal{P}_{\\Pi})$ _there exists a_ $\\widetilde{\\Delta}:[2m]\\to\\mathit{Str}(\\mathcal{G})$ _such that_ $$\\mathit{zip}\\Big{(}\\Pi\\big{[}\\pi\\mapsto\\mathit{Play}_{\\mathcal{G}}\\big{(}\\dot{s},\\prod_{i\\in\\mathit{Agts}}\\widetilde{\\Delta}(\\widetilde{x}(i))\\big{)}\\big{]}\\Big{)}\\in\\mathcal{L}(\\mathcal{A}).$$ _if and only if even_ $(\\mathit{Play}_{\\mathcal{P}_{\\Pi}}(\\mathcal{P}_{0},\\Delta))$_._\n* _For any_ $\\Delta:[2m]\\to\\mathit{Str}(\\mathcal{G})$ _there exists a_ $\\widetilde{\\Delta}:[2m]\\to\\mathit{Str}(\\mathcal{P}_{\\Pi})$ _such that_ $$\\mathit{zip}\\Big{(}\\Pi\\big{[}\\pi\\mapsto\\mathit{Play}_{\\mathcal{G}}\\big{(}\\dot{s},\\prod_{i\\in\\mathit{Agts}}\\Delta(\\widetilde{x}(i))\\big{)}\\big{]}\\Big{)}\\in\\mathcal{L}(\\mathcal{A}).$$\nProof. We show both claims separately.\n\nif and only if even(Play${}_{\\rm{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{\\bf{}}}}}}}}}}}}}}}}}}}}}$ (${}_{0}$, $\\bar{\\Delta}$)).\n\nProof. We show both claims sets\n- We translate strategies in P\u03a0 to strategies in G. Let \ud835\udc53 : \ud835\udc49 + \u2192 A\nbe some strategy in P\u03a0. We define \ufffd\ud835\udc53 : \ud835\udc46+ \u2192 A as follows: Let\n\ud835\udc62 \u2208 \ud835\udc46+ be given. Define \ud835\udc92 \u2208 \ud835\udc44+ as follows: We define \ud835\udc92(0) =\n\ud835\udc5e0 (the initial state of Adet). For 0 \u2264 \ud835\udc56 < |\ud835\udc62| we then define\n\ud835\udc92(\ud835\udc56 + 1) := \ud835\udeff(\ud835\udc92(\ud835\udc56), *zip*(\u03a0)(\ud835\udc56)[\ud835\udf0b \u21a6\u2192 \ud835\udc62(\ud835\udc56)]). The sequence \ud835\udc92 thus\ngives the unique state sequence in Adet when reading the first\n|\ud835\udc62| states of *zip*(\u03a0) extended with \ud835\udc62. Now consider the finite play\nin P\u03a0\n\ud835\udf0f = \ufffd\ud835\udc92(0),\ud835\udc62(0), 0\ufffd \u00b7 \u00b7 \u00b7 \ufffd\ud835\udc92(|\ud835\udc62| \u2212 1),\ud835\udc62(|\ud835\udc62| \u2212 1), |\ud835\udc62| \u2212 1\ufffd.\nThe intuition is that \ud835\udf0f corresponds to the unique path in P\u03a0\nthat, when projected onto the system state, gives \ud835\udc62. We define\n\ufffd\ud835\udc53 (\ud835\udc62) := \ud835\udc53 (\ud835\udf0f).\n\nFor any strategy assignment \u0394 : [2\ud835\udc5a] \u2192 *Str*(P\u03a0) in P\u03a0 we define \ufffd\u0394 : [2\ud835\udc5a] \u2192 *Str*(G) as the assignment obtained by applying\ufffd\u00b7 point wise.\n\nIt is now easy to see that *Play*G\n\ufffd\ufffd\ud835\udc60, \ufffd\n\ning \" point wise.\n\nIt is now easy to see that $Play_{\\mathcal{G}}\\big{(}i,\\prod_{i\\in Agt}\\widetilde{\\Delta}(\\widetilde{x}(i))\\big{)}\\big{)}\\in S^{\\omega}$ equals $Play_{\\mathcal{P}_{\\Pi}}(v_{0},\\Delta)$ (when projecting vertices in $Q\\times S\\times\\mathbb{N}$ on $S$). By construction, the automaton component in each vertex of $\\mathcal{P}_{\\Pi}$ simply simulates $\\mathcal{A}_{det}$ on the generated sequence of system state and thus accepts play iff the corresponding automaton sequence is accepting. We thus get that the\n\n$$\\mathit{zip}\\Big{(}\\Pi\\big{[}\\pi\\mapsto\\mathit{Play}_{\\mathcal{G}}\\big{(}i,\\prod_{i\\in Agt}\\widetilde{\\Delta}(\\widetilde{x}(i))\\big{)}\\big{]}\\Big{)}\\in\\mathcal{L}(\\mathcal{A})=\\mathcal{L}(\\mathcal{A}_{det})$$\n\nif and only if $\\mathit{even}(\\mathit{Play}_{\\mathcal{P}_{\\Pi}}(v_{0},\\Delta))$, as required.\n\nLet $f:S^{+}\\to\\mathbb{A}$ be a strategy in $\\mathcal{G}$. We define \n- Let \ud835\udc53 : \ud835\udc46+ \u2192 A be a strategy in G. We define \ufffd\ud835\udc53 : \ud835\udc49 + \u2192 A in\nP\u03a0 as follows: For any \ud835\udc62 \u2208 \ud835\udc49 + let \ud835\udc94 \u2208 \ud835\udc46+ be the projection on\nthe system state in \ud835\udc62. We define \ufffd\ud835\udc53 (\ud835\udc62) := \ud835\udc53 (\ud835\udc94), i.e., only query \ud835\udc53\non the sequences of system states. For any strategy assignment\n\u0394 : [2\ud835\udc5a] \u2192 *Str*(G) in P\u03a0 we define \ufffd\u0394 : [2\ud835\udc5a] \u2192 *Str*(P\u03a0) as the\nassignment obtained by applying\ufffd\u00b7 point wise. As in the first case,\n\ud835\udc56\u2208*Agts* \u0394(\ufffd\ud835\udc65(\ud835\udc56))\n\ufffd\n) \u2208 \ud835\udc46\ud835\udf14 is equal to it is easy to see that *Play*G\n\ufffd\ufffd\ud835\udc60, \ufffd\n\n_Play$\\varphi_{\\Pi}(v_{0},\\widetilde{\\Delta})$_ (when projecting vertices in $Q\\times S\\times\\mathbb{N}$ on $S$). As $\\mathcal{P}_{\\Pi}$ simulates $\\mathcal{A}_{\\mathrm{def}}$ on the sequence of system states we thus get\n\n$$\\mathit{zip}\\Big{(}\\Pi\\big{[}\\pi\\mapsto\\mathit{Play}_{\\mathcal{G}}\\big{(}\\dot{s},\\prod_{i\\in\\mathcal{A}_{\\mathrm{f\\!f\\!f\\!s}}}\\Delta(\\widetilde{x}(i))\\big{)}\\big{]}\\Big{)}\\in\\mathcal{L}(\\mathcal{A}).$$\n\nif and only if _even($\\mathit{Play}_{\\mathcal{P}_{\\Pi}}(v_{0},\\widetilde{\\Delta})$)_, as required. $\\Box$\n\nProposition 3. $\\mathcal{P}_{\\Pi}$_is won by the existential team if and only if_\n\n$$\\widetilde{b}.\\mathit{zip}\\Big{(}\\Pi\\big{[}\\pi\\mapsto\\mathit{Play}_{\\mathcal{G}}\\big{(}\\dot{s},\\prod_{i\\in\\mathcal{A}_{\\mathrm{f\\!f\\!s}}}f_{\\widetilde{x}(i)}\\big{)}\\big{]}\\Big{)}\\in\\mathcal{L}(\\mathcal{A}).\\tag{4}$$\n\nProof.: In $\\mathcal{P}_{\\Pi}$ we quantify over strategies in $\\mathcal{P}_{\\Pi}$ for each player in $[2m]$ (cf. Definition 6). Conversely, Eq. (4) uses the same quantization order (in the prefix $\\widetilde{b}$) but quantifies over strategies in $\\mathcal{G}$ via strategy variables $1,\\ldots,2m$ (Eq. 2). Using the translation in Lemma 10 we can translate any strategy assignment in $\\mathcal{P}_{\\Pi}$ to an equivalent one in $\\mathcal{G}$, and vice versa. As the type (i.e., universal or existential) and order of quantification is $\\mathcal{P}_{\\Pi}$ and Eq. (4) is the same (cf. Eq. 2) and we can translate strategies between $\\mathcal{G}$ and $\\mathcal{P}_{\\Pi}$, the result follows.\n"
    },
    {
        "level": "##",
        "title": "D.4 Positional Determinacy",
        "content": "\nThe more challenging direction is to show that P\u03a0 is won by the existential team iff B accepts *zip*(\u03a0). The key challenge is that the way strategies are quantified is fundamentally different: In P\u03a0 we quantify over full strategies in advance (i.e., \"outside\") and in B\nwe (conjunctively or disjunctively) pick actions in each step of the automaton (i.e., \"inside\"). The key ingredient we use is the positional determinacy of CPGs. Intuitively, a positional strategy is one that decides on an action based solely on the current vertex of the game.\n\nDefinition 7. A positional strategy in P = (\ud835\udc49, \ud835\udc630, A,\ud835\udc5a, \ud835\udf07,\ud835\udc50) is a function \ud835\udc53 : \ud835\udc49 \u2192 A. We write *PosStr*(P) for the set of all positional strategies in P.\n\nPositional determinacy in the context of (classical) turn-based\n2-player parity games means that players can pick an action based solely on the current vertex of the game. In contrast, the quantification over strategies in CPGs can have multiple alternations, the strategy for each player thus depends on the current vertex of the game and the action selected by all strategies quantified before it. We will represent the existentially quantified strategies using Skolem functions (known, e.g., from first-order logic and sometimes called *dependence map* [45]) that get the actions selected by strategies quantified earlier as an explicit input.\n\nDefinition 8. A positional\ud835\udc58-Skolem strategy CPG P = (\ud835\udc49, \ud835\udc630, A,\n\ud835\udc5a, \ud835\udf07,\ud835\udc50) is a function \ud835\udf01 : \ud835\udc49 \u00d7 A\ud835\udc58 \u2192 A. We write SkoStr(P,\ud835\udc58) for the set of positional \ud835\udc58-Skolem strategies in P.\n\nA positional \ud835\udc58-Skolem strategy \ud835\udf01 can pick an action based on the current vertex of the game and \ud835\udc58 actions that have been selected previously. The intuition is that the strategy for player (or strategy variable) 2\ud835\udc58 (which is existentially quantified) can observe the actions selected by the \ud835\udc58-universally quantified strategies before it.\n\nDefinition 9. Assume \ud835\udc86 *is a function that maps each* \ud835\udc58 \u2208 [\ud835\udc5a]\nto a positional \ud835\udc58-Skolem strategy in P *and let* \ud835\udc90 : [\ud835\udc5a] \u2192 *PosStr*(P)\nmap each each \ud835\udc58 \u2208 [\ud835\udc5a] to a positional strategy in P. We combine \ud835\udc86\nand \ud835\udc90 into a mapping *com*(\ud835\udc86, \ud835\udc90) : [2\ud835\udc5a] \u2192 *Str*(P) as follows. For a path \ud835\udc62 \u2208 \ud835\udc49 +, we define *last*(\ud835\udc62) \u2208 \ud835\udc49 as the last vertex in \ud835\udc63. For an odd index 2\ud835\udc58 \u2212 1 we then define com(\ud835\udc86, \ud835\udc90)(2\ud835\udc58 \u2212 1) : \ud835\udc49 + \u2192 A as com(\ud835\udc86, \ud835\udc90)(2\ud835\udc58 \u2212 1)(\ud835\udc62) := \ud835\udc90(\ud835\udc58)\ufffd*last*(\ud835\udc62)\ufffd\nFor an even index 2\ud835\udc58 we define com(\ud835\udc86, \ud835\udc90)(2\ud835\udc58) : \ud835\udc49 + \u2192 A as com(\ud835\udc86, \ud835\udc90)(2\ud835\udc58)(\ud835\udc62) := \ud835\udc86(\ud835\udc58)\ufffdlast(\ud835\udc62), (\ud835\udc90(1)(last(\ud835\udc62)),\n\ud835\udc90(3)(last(\ud835\udc62)),\n. . . ,\n\ud835\udc90(2\ud835\udc58 \u2212 1)(*last*(\ud835\udc62)))\ufffd.\n\nThe idea of *com*(\ud835\udc86, \ud835\udc90) is to combine the Skolem strategies in \ud835\udc86\nand the positional strategies in \ud835\udc90 into a strategy for each player. For odd player we simply take the strategy given by \ud835\udc90 (applying it to the last vertex in the given sequence). For even players, we query the Skolem strategy given by \ud835\udc86 and provide it with the actions that all universally quantified (odd) strategies before it have selected.\n\nWe can now state that CPG are positionally determined by making use of Skolem functions:\n\nProposition 4 ([40]).: _Let $\\mathcal{P}=(V,v_{0},\\mathbb{A},m,\\mu,c)$ be a CPG. We have that $\\mathcal{P}$ is won by the existential players if and only if_\n\n$$\\begin{array}{c}\\includegraphics[]{142.26378pt}\\end{array}$$\n\n$$\\begin{array}{c}\\includegraphics[]{142.26378pt}\\end{array}$$\n\n$$\\begin{array}{c}\\includegraphics[]{142.26378pt}\\end{array}$$\n\n$$\\begin{array}{c}\\includegraphics[]{142.26378pt}\\end{array}$$\n\n_where $\\boldsymbol{e}(k):=\\zeta_{k}$ and $\\boldsymbol{o}(k):=f_{k}$ for $k\\in[m]$._\n\nProposition 4 states that instead of following the quantifier prefix as in Definition 6 we can instead quantify over Skolem functions $\\zeta_{1},\\ldots,\\zeta_{m}$ for all existentially quantified variables. Put informally, the proposition thus states that existentially quantified strategies only need to know the current vertex and all actions selected by universally quantified strategies quantified before it. A proof Proposition 4 follows directly from the the construction in [40, Thm. 4.1].\n"
    },
    {
        "level": "##",
        "title": "D.5 The Second Implication",
        "content": "\nUsing Proposition 4 we can now prove:\nProposition 5. P\u03a0 is won by the existential team if and only if zip(\u03a0) \u2208 L(B).\n\nWe prove both directions of Proposition 5 separately (in Lemmas 11 and 12).\n\nLemma 11. If P\u03a0 is won by the existential team then *zip*(\u03a0) \u2208\nL(B).\n\nProof. Assume that $\\mathcal{P}_{\\Pi}$ is won by the existential player. Using Proposition 4 we thus get positional skeleton functions $\\zeta_{1},\\ldots,\\zeta_{m}$ such that for\n\n$$\\bigvee_{k\\in[m]}f_{k}\\in\\mathit{PosStr}(\\mathcal{P}).\\;\\mathit{even}\\Big{(}\\mathit{Play}_{\\mathcal{P}_{\\Pi}}(v_{0},\\prod_{k\\in[2m]}\\mathit{com}(\\boldsymbol{e},\\boldsymbol{o})(k)\\Big{)}\\tag{5}$$\n\nwhere $\\boldsymbol{e}(k):=\\zeta_{k}$ and $\\boldsymbol{o}(k):=f_{k}$ for $k\\in[m]$.\n\nWe use the Skolem functions to construct an accepting run DAG $\\mathbb{D}$ of $\\mathcal{B}$ on $\\mathit{zip}(\\Pi)$. We construct $\\mathbb{D}$ iteratively. We begin with a DAG that consist of the single node $((q_{0},\\dot{s}),0)$, i.e., we start with the  unique initial state of $\\mathcal{B}$ (note that by definition of run DAGs, nodes are indexed by their current depth, cf. Appendix A). Now assume that there exists some node that we have not visited. Let this note be $((q,s),N)$. We observe that $(q,s,N)$ is a vertex in $\\mathcal{P}_{\\Pi}$.\n\nThe Nth input read by $\\mathcal{B}$ on $zip(\\Pi)$ is $zip(\\Pi)(N)$. By definition of $\\mathcal{B}$ the transition function from $(q,s)$ on the Nth input is\n\n$$\\delta^{\\prime}\\big{(}(q,s),zip(\\Pi)(N)\\big{)}=\\bigwedge_{a_{1}\\in\\mathbb{A}}\\bigvee_{a_{2}\\in\\mathbb{A}}\\cdots\\bigvee_{a_{2m}\\in\\mathbb{A}}(q^{\\prime},s^{\\prime})\\tag{6}$$\n\nwhere $q^{\\prime}=\\delta(q,zip(\\Pi)(N)[\\pi\\mapsto s])$ and $s^{\\prime}=\\kappa\\big{(}s,\\prod_{i\\in Agts}a_{\\overline{x}\\,(i)}\\big{)}$.\n\nWe need to add children of the node $((q,s),N)$ that full the above formula. We will construct a set $Y\\subseteq Q\\times S$ that is a model for the above, i.e., $Y\\models\\delta^{\\prime}\\big{(}(q,s),zip(\\Pi)(N)\\big{)}$. We will construct $Y$ by following all the action selection in the prefix of $\\delta^{\\prime}\\big{(}(q,s),zip(\\Pi)(N)\\big{)}$ and construct an intermediate set of functions $Z\\subseteq([2m]\\rightharpoonup\\mathbb{A})$. We can think of $Z$ as combinations of actions $a_{1},\\ldots,a_{2m}$ that we set \n\nand construct an intermediate set of functions \ud835\udc4d \u2286 ([2\ud835\udc5a] \u21c0 A).\nWe can think of \ud835\udc4d as combinations of actions \ud835\udc4e1, . . . ,\ud835\udc4e2\ud835\udc5a that we se-\nlect in the prefix of Eq. (6). This set \ud835\udc4d is constructed in accordance\nwith the Skolem functions \ud835\udf011, . . . ,\ud835\udf01\ud835\udc5a, i.e., for every disjunctive\nchoice we will selected the action that is picked by the respective\nSkolem function. Initially, we set \ud835\udc4d = {{}} as the singleton set\ncontaining only the empty function {} : [2\ud835\udc5a] \u21c0 A. For every \ud835\udc58\nfrom 1 to 2\ud835\udc5a we do the following: If \ud835\udc58 is odd, so action \ud835\udc4e\ud835\udc58 is cho-\nsen conjunctively we add all possible actions. That is, we update\n\ud835\udc4d := {\ufffd\ud835\udc4e[\ud835\udc58 \u21a6\u2192 \ud835\udc4e] | \ufffd\ud835\udc4e \u2208 \ud835\udc4d,\ud835\udc4e \u2208 A}. If \ud835\udc58 is even, so \ud835\udc58 = 2\ud835\udc58\u2032 for some\n\ud835\udc58\u2032, we can pick one action for \ud835\udc58 for each element in \ud835\udc4d. Given \ufffd\ud835\udc4e \u2208 \ud835\udc4d\n(so \ufffd\ud835\udc4e is a function {1, . . . ,\ud835\udc58 \u2212 1} \u2192 A) we define the action \ud835\udc4e \ufffd\ud835\udc4e as\n\n\ud835\udc4e \ufffd\ud835\udc4e := \ud835\udf01\ud835\udc58\u2032 \ufffd(\ud835\udc5e,\ud835\udc60, \ud835\udc41), (\ufffd\ud835\udc4e(1), \ufffd\ud835\udc4e(3), . . . , \ufffd\ud835\udc4e(2\ud835\udc58\u2032 \u2212 1))\ufffd.\n\n\ud835\udc56\u2208Agts \ufffd\ud835\udc4e(\ufffd\ud835\udc65(\ud835\udc56))\ufffd. We then define\n\nThat is, we use the \ud835\udc58\u2032th Skolem functions and query it with the\ncurrent vertex (\ud835\udc5e,\ud835\udc60, \ud835\udc41) and the action selected by all previously\nchosen conjunctive action choices (at odd positions) in \ufffd\ud835\udc4e. We then\nupdate \ud835\udc4d := {\ufffd\ud835\udc4e[\ud835\udc58 \u21a6\u2192 \ud835\udc4e \ufffd\ud835\udc4e] | \ufffd\ud835\udc4e \u2208 \ud835\udc4d}.\n  After repeating this procedure, we have constructed a set \ud835\udc4d \u2286\n([2\ud835\udc5a] \u2192 A) that maps all players to actions. Informally, this corre-\nsponds to a possible assignment of the actions selected in the prefix\nof \ud835\udeff\u2032\ufffd(\ud835\udc5e,\ud835\udc60), zip(\u03a0)(\ud835\udc41)\ufffd. For each \ufffd\ud835\udc4e \u2208 \ud835\udc4d we can define a unique \ud835\udc60 \ufffd\ud835\udc4e\nby following the construction in the definition of B. That is, we\ndefine \ud835\udc60 \ufffd\ud835\udc4e = \ud835\udf05\ufffd\ud835\udc60, \ufffd\n\n\ud835\udc4c :=\n   \ufffd\ufffd\ud835\udeff(\ud835\udc5e, zip(\u03a0)(\ud835\udc41)[\ud835\udf0b \u21a6\u2192 \ud835\udc60]),\ud835\udc60 \ufffd\ud835\udc4e\n                         \ufffd | \ufffd\ud835\udc4e \u2208 \ud835\udc4d\n                               \ufffd\n                                .\n\nIt is easy to see that \ud835\udc4c |= \ud835\udeff\u2032\ufffd(\ud835\udc5e,\ud835\udc60), zip(\u03a0)(\ud835\udc41)\ufffd: In the selection of\nactions (when constructing \ud835\udc4d) we have consider all possible actions\nfor each conjunctive choice and picked a particular action for each\ndisjunctive choice.\n  In our run DAG we now add a node ((\ud835\udc5e\u2032,\ud835\udc60\u2032), \ud835\udc41 + 1) for each\n(\ud835\udc5e\u2032,\ud835\udc60\u2032) \u2208 \ud835\udc4c, and add an edge from ((\ud835\udc5e,\ud835\udc60), \ud835\udc41) to ((\ud835\udc5e\u2032,\ud835\udc60\u2032), \ud835\udc41 + 1).\n  Let D be the infinite DAG obtained by following this construction.\nIt is easy to see that D is a valid run of B on zip(\u03a0) (as we have\nargued above all children that we add to any given node satisfy the\ntransition formula).\n  It remains to argue that D is accepting. For this we consider an\narbitrarily infinite path \ud835\udf0f in D, s.t.,\n\n\ud835\udf0f = ((\ud835\udc5e0,\ud835\udc600), 0)((\ud835\udc5e1,\ud835\udc601), 1)((\ud835\udc5e2,\ud835\udc602), 2) \u00b7 \u00b7 \u00b7\n\nWe define an analogous path in P\u03a0 as follows (by simply regrouping\nparenthesis):\n\n$$\\tau^{\\prime}=(q_{0},s_{0},0)(q_{1},s_{1},1)(q_{2},s_{2},2)\\cdots.$$\n\nIn construction $\\mathbb{D}$, we always mimicked the choice for each distinctively chosen action by using the Skolem functions $\\zeta_{1},\\ldots,\\zeta_{m}$. We thus get that $\\tau^{\\prime}$ is a play in $\\mathcal{P}_{\\Pi}$ under these Skolem functions: That is, there exist $f_{1},f_{2},\\ldots,f_{m}\\in\\mathit{P}\\mathit{o}\\mathit{S}tr(\\mathcal{P}_{\\Pi})$ such that\n\n$$\\mathit{Play}_{\\mathcal{P}_{\\Pi}}(v_{0},\\prod_{k\\in[2m]}com(\\boldsymbol{e},\\boldsymbol{o})(k))=\\tau^{\\prime}$$\n\nwhere $\\boldsymbol{e}(k):=\\zeta_{k}$ and $\\boldsymbol{o}(k):=f_{k}$ for $k\\in[m]$. By the choice of $\\zeta_{1},\\ldots,\\zeta_{m}$ (cf. Eq. (5)) we thus get that $even(\\tau^{\\prime})$.\n\nNow the sequence of colors traversed in $\\tau^{\\prime}$ is the same as the sequence of colors in the path $\\tau$ in the run DAG. The minimal color that appears infinitely often in $\\tau$ is thus also even and so the path is accepting. As this holds for all paths, $\\mathbb{D}$ is accepting.\n\nWe have constructed an accepting run DAG of $\\mathcal{B}$ on $zip(\\Pi)$, so $zip(\\Pi)\\in\\mathcal{L}(\\mathcal{B})$ as required.\n\nLemma 12. If *zip*(\u03a0) \u2208 L(B) then P\u03a0 is won by the existential team.\n\n(7)\n\nProof. Assume that $zip(\\Pi)\\in\\mathcal{L}(\\mathcal{B})$, and let $\\mathbb{D}$ be an accepting run DAG of $\\mathcal{B}$. We will use this DAG to construct Skolem functions $\\zeta_{1},\\ldots,\\zeta_{m}$ such that\n\n$$\\bigvee_{k\\in[m]}f_{k}\\in\\mathit{PosStr}(\\mathcal{P}).\\,\\mathit{even}\\Big{(}\\mathit{Play}_{\\mathcal{P}_{\\Pi}}(v_{0},\\prod_{k\\in[2m]}com(\\boldsymbol{e},\\boldsymbol{o})(k))\\Big{)}\\tag{7}$$\n\nwhere $\\boldsymbol{e}(k):=\\zeta_{k}$ and $\\boldsymbol{o}(k):=f_{k}$ for $k\\in[m]$. By Proposition 4 this would imply that $\\mathcal{P}_{\\Pi}$ is won by the existential team.\n\nFor any node $x=((q,s),N)$ in the run DAG $\\mathbb{D}$, the children of $((q,s),N)$ satisfy \n\ufffd\n\ud835\udc4e1\u2208A\n\n$$\\begin{array}{c}\\bigvee\\cdots\\bigvee(q^{\\prime},s^{\\prime})\\\\ a_{1}\\in\\mathbb{A}\\quad a_{2m}\\in\\mathbb{A}\\end{array}$$\n\ud835\udeff\u2032\ufffd(\ud835\udc5e,\ud835\udc60), *zip*(\u03a0)(\ud835\udc41)\ufffd =\n\ufffd\nwhere \ud835\udc5e\u2032 = \ud835\udeff(\ud835\udc5e, *zip*(\u03a0)(\ud835\udc41)[\ud835\udf0b \u21a6\u2192 \ud835\udc60]) and \ud835\udc60\u2032 = \ud835\udf05\ufffd\ud835\udc60, \ufffd\n\ud835\udc56\u2208*Agts* \ud835\udc4e \ufffd\ud835\udc65 (\ud835\udc56)\n\ufffd.\n\nWe will construct functions \ud835\udefc\ud835\udc65\n1 *, . . . , \ud835\udefc*\ud835\udc65\ud835\udc5a where \ud835\udefc\ud835\udc65\n\ud835\udc58 : A\ud835\udc58 \u2192 A that will pick a choice for each disjunction based on the previous choices for each conjunction. We first define \ud835\udefc\ud835\udc65\n1 : A \u2192 A: For any \ud835\udc4e1 \u2208 A\nwe define \ud835\udefc\ud835\udc65\n1 (\ud835\udc4e1) by *fixing* the first conjunctively chosen action \ud835\udc4e1\nin Eq. (8) to be \ud835\udc4e1. As \ud835\udc4e1 was chosen conjunctivley, the children of\n\ud835\udc65 = ((\ud835\udc5e,\ud835\udc60), \ud835\udc41) still satisfy Eq. (8) with \ud835\udc4e1 fixed to \ud835\udc4e1. Now define\n\ud835\udc4e2 \u2208 A as some valid choice for the (disjunctively chosen) \ud835\udc4e2. That is, we define \ud835\udc4e2 such that the children of \ud835\udc65 = ((\ud835\udc5e,\ud835\udc60), \ud835\udc41) in D still form a model of Eq. (8) with actions \ud835\udc4e1 := \ud835\udc4e1,\ud835\udc4e2 := \ud835\udc4e2 fixed. We set\n\ud835\udefc\ud835\udc65\n1 (\ud835\udc4e1) := \ud835\udc4e2. After having defined \ud835\udefc\ud835\udc65\n1 we can define \ud835\udefc\ud835\udc65\n2 (\ud835\udc4e1,\ud835\udc4e3): We fix the first conjunctively chosen action be\ud835\udc4e1, the second disjunctive action be \ud835\udefc\ud835\udc65\n1 (\ud835\udc4e1) and the second conjunctive action be \ud835\udc4e3, and the define \ud835\udefc\ud835\udc65\n2 (\ud835\udc4e1,\ud835\udc4e3) as some action that we can select for the second disjunctive choice such that the children of \ud835\udc65 = ((\ud835\udc5e,\ud835\udc60), \ud835\udc41) in D\nsatisfy the subformula with those actions fixed. The construction of the remaining \ud835\udefc\ud835\udc65\n1 *, . . . , \ud835\udefc*\ud835\udc65\ud835\udc5a is analogous. Intuitively, each \ud835\udefc\ud835\udc65\n\ud835\udc58 serves as a Skolem function for the \ud835\udc58th disjunctive action by fixing an action based solely on the earlier conjunctive actions. Together they guarantee that by following the selected action by each Skolem function for each disjunctive choice, we always reach some child of \ud835\udc65 = ((\ud835\udc5e,\ud835\udc60), \ud835\udc41) in D.\n\nWe can now define the desired positional Skolem functions\n\ud835\udf011*, . . . ,\ud835\udf01*\ud835\udc5a for P\u03a0. We define \ud835\udf01\ud835\udc58 as follows: Given any vertex \ud835\udc63 =\n(*\ud835\udc5e,\ud835\udc60, \ud835\udc41*) in P\u03a0 and actions \ud835\udc4e1*, . . . ,\ud835\udc4e*\ud835\udc58 \u2208 A (corresponding to the actions selected by all universally quantified strategies before 2\ud835\udc58) we check if \ud835\udc65 := ((\ud835\udc5e,\ud835\udc60), \ud835\udc41) is a node in D. If there does not exists such a node we can return an arbitrary action (we will later argue that this situation will never be reached in any play P\u03a0). Otherwise \ud835\udc65 is a node in D and we get the Skolem functions \ud835\udefc\ud835\udc65\n1 *, . . . , \ud835\udefc*\ud835\udc65\ud835\udc5a we have constructed earlier. We define \ud835\udf01\ud835\udc58 (\ud835\udc63, (\ud835\udc4e1, . . . ,\ud835\udc4e\ud835\udc58)) := \ud835\udefc\ud835\udc65\n\ud835\udc58 (\ud835\udc4e1*, . . . ,\ud835\udc4e*\ud835\udc58), i.e., we select the action that \ud835\udefc\ud835\udc65\n\ud835\udc58 picks for the \ud835\udc58th disjunction when using the actions \ud835\udc4e1*, . . . ,\ud835\udc4e*\ud835\udc58 for the previous \ud835\udc58 conjunctions.\n\nIt remains to argue that the Skolem functions \ud835\udf011*, . . . ,\ud835\udf01*\ud835\udc5a fulfill Eq. (7). Let \ud835\udc531, . . . .\ud835\udc53\ud835\udc5a \u2208 *PosStr*(P\u03a0) and consider the resulting play\n\n\ud835\udf0f = *Play*P\u03a0 \ufffd\ud835\udc630, \ufffd \ud835\udc58\u2208[2\ud835\udc5a] com(\ud835\udc86, \ud835\udc90)(\ud835\udc58)\ufffd = (\ud835\udc5e0,\ud835\udc600, 0)(\ud835\udc5e1,\ud835\udc601, 1)(\ud835\udc5e2,\ud835\udc602, 2) \u00b7 \u00b7 \u00b7\nwhere \ud835\udc86(\ud835\udc58) := \ud835\udf01\ud835\udc58 and \ud835\udc90(\ud835\udc58) := \ud835\udc53\ud835\udc58 for \ud835\udc58 \u2208 [\ud835\udc5a]. We consider the equivalent path in the run DAG (by regrouping parenthesis):\n\n\ud835\udf0f\u2032 = ((\ud835\udc5e0,\ud835\udc600), 0)((\ud835\udc5e1,\ud835\udc601), 1)((\ud835\udc5e2,\ud835\udc602), 2) \u00b7 \u00b7 \u00b7 .\nBy construction of \ud835\udf011*, . . . ,\ud835\udf01*\ud835\udc5a we always pick the actions that are disjunctively chosen in accordance with D. It is therfore easy to see that \ud835\udf0f\u2032 is an infinite path in D. By the assumption that D is accepting the minimal color that appears infinitely often is even.\n\nAs the automaton state sequence agrees with that of \ud835\udf0f, we thus get that *even*(\ud835\udf0f) holds. So \ud835\udf011*, . . . ,\ud835\udf01*\ud835\udc5a satisfy Eq. (7). By Proposition 4 this implies that P\u03a0 is won by the existential team, as required.\n\n\u25a1\nBy Proposition 3, we get that \u03a0 satisfies Eq. (3) iff P\u03a0 is won by the existential team (Proposition 3). By Proposition 5, P\u03a0 is won by the existential team iff *zip*(\u03a0) \u2208 L(B). Consequently, \u03a0\nsatisfies Eq. (3) iff *zip*(\u03a0) \u2208 L(B), proving Lemma 9 and thus of Proposition 2.\n"
    },
    {
        "level": "##",
        "title": "E Details On The Section 7",
        "content": "\nIn this section, we provide additional details on the formulas checked in Section 7.\n"
    },
    {
        "level": "##",
        "title": "E.1 Details On Section 7.1",
        "content": "\nWe check the following HyperSL[SPE] formula:\n\u2203\ud835\udc65. \u2200\ud835\udc651, . . . ,\ud835\udc65\ud835\udc5b.\n\n\ufffd \ud835\udc5b\n\ufffd\n\n\ud835\udc56=1\n     G \ufffd\u27e8wt,\ud835\udc56\u27e9\ud835\udf0b \u2192 F \u00ac\u27e8wt,\ud835\udc56\u27e9\ud835\udf0b\n                                               \ufffd\n                                                \ufffd\n\n[\ud835\udf0b : (\ud835\udc60\ud835\udc50\u210e\ud835\udc52\ud835\udc51 \u21a6\u2192 \ud835\udc65,\ud835\udc661 \u21a6\u2192 \ud835\udc651, . . . ,\ud835\udc66\ud835\udc5b \u21a6\u2192 \ud835\udc65\ud835\udc5b)]\n\nThis formula states that the scheduling agent sched has a strategy\nsuch that none of the working agents \ud835\udc661, . . . ,\ud835\udc66\ud835\udc5b starves, i.e., when-\never agent \ud835\udc66\ud835\udc56 waits for a grant (modeled by proposition \u27e8wt,\ud835\udc56\u27e9), it\nwill eventually not wait any more. Note that this formula is equiv-\nalent to the SL[1G] specification used by Cerm\u00e1k et al. [23]. We\ncheck it for various values of \ud835\udc5b \u2208 N and give the results in Table 1.\n"
    },
    {
        "level": "##",
        "title": "E.2 Details On Section 7.2",
        "content": "\nIn Section 7.2, we check random formulas from a range of different families. We assume we are given a CGS G over atomic proposition AP and agents *Agts* (These CGS are obtained automatically from the ISPL models from [39]).\n\nSecurity (Sec). We select some agent \ud835\udc56 \u2208 *Agts* and some AP\n\ud835\udc54 \u2208 AP modeling a goal, an AP \u210e \u2208 AP modelling a high-security input, and an AP \ud835\udc5c \u2208 AP modeling an observable output. We then construct the following HyperSL[SPE] formula:\n\u2203\ud835\udc65. \u2200\ud835\udc661, . . . ,\ud835\udc66\ud835\udc56\u22121,\ud835\udc66\ud835\udc56+1, . . . ,\ud835\udc66\ud835\udc5b. \u2203\ud835\udc671, . . . ,\ud835\udc67\ud835\udc5b.\n\n$$(\\mathsf{F}\\,g_{\\pi}\\wedge\\mathsf{G}(o_{\\pi}\\leftrightarrow o_{\\pi^{\\prime}})\\wedge\\mathsf{F}(h_{\\pi}\\leftrightarrow h_{\\pi^{\\prime}}))$$ $$\\begin{bmatrix}\\pi:(y_{1},\\ldots,y_{i-1},x,y_{i+1},\\ldots,y_{n})\\\\ \\pi^{\\prime}:(z_{1},\\ldots,z_{n})\\end{bmatrix}$$\n\nThis formula states that $i$ has a strategy to eventually reach $g$. Moreover, it may not leak all information about $h$ via $o$. We model this using the idea of non-inference [43]. The idea is that the behavior in $o$ should not leak $h$, so there must be \"plausible denomibility\". That is, the same observation via $o$ is also possible for some different input sequence via $h$.\n\nConcretely, $i$ should be able to reach $g$ on path $\\pi$ no matter what the other agents play. In addition, there must exists some path $\\pi^{\\prime}$ (which we state by quantifying the strategies of all agents existentially), that has the same observations $\\mathsf{G}(o_{\\pi}\\leftrightarrow o_{\\pi^{\\prime}})$ but a different high-security input $(\\mathsf{F}(h_{\\pi}\\leftrightarrow h_{\\pi^{\\prime}}))$.\n\nGood-Enough Synthesis (GE). In many situations, asking for a strategy that wins in all situations is too restrictive. Instead, it often suffices to look for strategies that are *good-enough* (GE), i.e., strategies that win on every possible input sequence for which there exists a winning output sequence [1, 3]. We can express this formally using HyperSL[SPE]. Concretely, assume that \ud835\udf11 =\nQ1\ud835\udc651*, . . . ,* Q\ud835\udc5a\ud835\udc65\ud835\udc5a.\ud835\udf13 [\ud835\udf0b : \ufffd\ud835\udc65] is any HyperSL formula over a single path variable (or, equivalently, a SL[1G] formula). We want to express that that \ud835\udf11 only needs to holds on traces with input \ud835\udc56 \u2208 AP, on which some path with the same input actually satisfies \ud835\udf13.\n\nWe can express that \ud835\udf11 is a GE-strategy as follows:\n\n$$\\mathbb{Q}_{1}x_{1},\\ldots,\\mathbb{Q}_{m}x_{m}.\\,\\forall y_{1},\\ldots,y_{m}.$$ $$(\\mathbb{G}(i_{\\pi}\\leftrightarrow i_{\\pi^{\\prime}})\\wedge\\psi[\\pi^{\\prime}/\\pi])\\to\\psi$$\n\nwhere we write $\\psi[\\pi^{\\prime}/\\pi]$ for the formula with all occurrences of $\\pi$ replaced with $\\pi^{\\prime}$.\n\nIn the formula, we quantify over strategies $x_{1},\\ldots,x_{m}$ as in $\\varphi$ and use these strategies to construct path $\\pi$. Afterwards, we universally quantify over any path $\\pi^{\\prime}$ in the system by picking strategies $y_{1},\\ldots,y_{n}$ for all agents. We then state that $\\psi$ only needs to hold on $\\pi$ provided $\\pi^{\\prime}$ has the same input and satisfies $\\psi$. Phased differently, $\\pi$ only needs to win, provided some path with the same inputs can ensure $\\psi$. Note that, depending on the prefix in $\\varphi$, this is not expressible in weaker hyperlogics such as HyperATL${}^{*}$ and HyperATL${}^{*}_{S}$.\n\nRandom (Rnd). For the random category, we use a random LTL\nformula (sampled using spot [30]) and add a prefix of quantifiers to yield a HyperSL[SPE] formula."
    }
]